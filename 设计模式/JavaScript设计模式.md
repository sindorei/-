#设计模式
面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案

在某中场合下对某个问题的一种解决方案

给面向对象软件开发总的一些好的设计取个名字
#单例模式
 - 透明的单例模式
 - 用代理实现单例
 - 惰性单例
#策略模式
#代理模式
 * 虚拟代理
 * 缓存代理
 
 #装饰者模式
给对象动态地增加职责的方式
### AOP装饰函数

`Function.prototype.before`和`Function.prototype.after`方法

```javascript
Function.prototype.before = function(beforefn){
    var __self = this; //保存原函数的引用
    return function(){ // 返回包含了原函数和新函数的代理函数
        beforefn.apply(this,arguments); // 执行新函数，且保证this不被劫持，新函数接受的参数也会被原封不动地传入原函数，新函数在原函数之前执行
        return __self.apply(this,arguments); // 执行原函数并返回原函数的执行结果，并且保证this不被劫持
    }
} 

Function.prototype.after = function( afterfn ){
    var __self = this;
    return function() {
        var ret = __self.apply(this,arguments);
        afterfn.apply(this,arguments);
        return ret;
    }
}
```

注意：函数通过`Function.prototype.before`和`Function.prototype.after`被装饰后，返回的实际上是一个新函数，如在原函数上保存了一些属性，那么这些属性会丢失。

另这种装饰方式也叠加了函数的作用域，如果装饰的链条太长，性能上也会受到一些影响

#设计原则与编程技巧

## 单一职责原则
## 最少知识原则
## 开放封闭原则

开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序源代码。

用对象的多态性消除条件分支

把程序中不变的部分隔离出来，把可变的部分封装起来

帮助我们编写遵守开发-封闭原则的代码：
 1. 放置挂钩（hook）
 2. 使用回调函数
 
 有些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。
 
 * 挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化
 * 在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。
 
# 接口和面向接口编程

接口的几种含义：
* 经常说的一个库或者模块对外提供了某某api接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。
* 语言提供的关键字 interface。产生一个完全抽象的类，用来表示一种契约，专门负责建立类与类之间的联系。
* 面向接口编程中的接口
  
  接口是对象能响应的请求的集合
  
  抽象类和infterfacede作用主要都是：
  * 通过向上转型来隐藏对象的真正类型，以表现对象的多态性
  * 约定类与类之间的一些契约行为

# 代码重构

* 提炼函数
  * 避免出现超大函数
  * 独立出来的函数有助于代码复用
  * 独立出来的函数更容易被覆写
  * 独立出来的函数如果拥有良好的命名，它本身就起到了注释的作用
* 合并重复的条件片段

如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散步了一些重复的代码，那么久有必要进行合并去重工作。

* 把条件分支语句提炼成函数

复杂的条件分支语句是导致程序难以阅读和理解的重要原因，而且容易导致一个庞大的函数。

* 合理使用循环

在函数体内，如果有些代码负责的是一些重复性的工作，那么合理利用循环不仅可以完成同样的功能，还可以使代码量更少。

* 提前让函数退出，代替嵌套条件分支

面对一个嵌套的if分支时，我们可以把外层if表达式进行反转

* 传递对象参数代替过长的参数列表
* 尽量减少参数数量
* 少用三目运算符
* 合理使用链式调用

链式调用会导致调试和维护困难

* 分解大型类

面向对象设计鼓励将行为分布在合理数量的更小对象之中

* 用return退出多重循环

用return直接退出方法会带来一个问题，如果在循环之后还有一些要被执行的代码，退出之后，这些代码就不能执行。

可把循环后面的代码放到return 后面，如果代码比较多，就提炼成一个单独的函数。
