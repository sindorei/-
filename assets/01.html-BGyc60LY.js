import{_ as i,c as a,f as e,o as n}from"./app-LHpjaFTr.js";const s={};function t(r,l){return n(),a("div",null,l[0]||(l[0]=[e('<h1 id="基本操作" tabindex="-1"><a class="header-anchor" href="#基本操作"><span>基本操作</span></a></h1><ul><li>代码必须正确无bug</li><li>正确地使用数据库的失误</li></ul><h1 id="订单系统的核心功能和数据" tabindex="-1"><a class="header-anchor" href="#订单系统的核心功能和数据"><span>订单系统的核心功能和数据</span></a></h1><ul><li>创建订单</li><li>随着购物流程更新订单状态</li><li>查询订单，包括用订单数据生成各种报表</li></ul><h2 id="表" tabindex="-1"><a class="header-anchor" href="#表"><span>表</span></a></h2><ul><li><p>订单主表</p><ul><li>保存订单的基本信息</li></ul></li><li><p>订单商品表</p><ul><li>保存订单中的商品信息</li></ul></li><li><p>订单支付表</p><ul><li>保存订单的支付和退款信息</li></ul></li><li><p>订单优惠表</p><ul><li>保存订单使用的所有优惠信息</li></ul></li></ul><h1 id="如何避免重复下单" tabindex="-1"><a class="header-anchor" href="#如何避免重复下单"><span>如何避免重复下单</span></a></h1><ul><li>让订单服务具备幂等性 <ul><li>可以利用数据库的主键唯一约束特性，在插入数据的时候带上主键，来解决创建订单服务的幂等性问题</li><li>用户进入创建订单页面时，前端调用生成订单号服务</li><li>提交订单时带上生成的订单号</li><li>重复订单返回创建成功，避免返回失败前端提示失败而实际创单成功</li></ul></li></ul><h1 id="如何解决aba问题" tabindex="-1"><a class="header-anchor" href="#如何解决aba问题"><span>如何解决ABA问题</span></a></h1><ul><li>数据库更新操作本身就具备天然的幂等性</li><li>但在并发环境下需要注意ABA问题 <ul><li>新增<code>version</code>列</li><li>更新判断<code>version</code>，并把<code>version+1</code></li></ul></li></ul><h1 id="思考" tabindex="-1"><a class="header-anchor" href="#思考"><span>思考</span></a></h1><ul><li>还有哪些实现幂等的方法 <ul><li>通过一些精巧的设计让更新本身就是幂等的</li><li>利用外部的、具备一致性的存储（如MySQL）来做冲突检测</li></ul></li></ul>',12)]))}const o=i(s,[["render",t],["__file","01.html.vue"]]),h=JSON.parse('{"path":"/geektime/back-end-storage-practical-lession/01.html","title":"基本操作","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"表","slug":"表","link":"#表","children":[]}],"git":{"updatedTime":1644980618000,"contributors":[{"name":"sindorei","email":"wupan1030@foxmail.com","commits":1,"url":"https://github.com/sindorei"}]},"filePathRelative":"geektime/back-end-storage-practical-lession/01.md"}');export{o as comp,h as data};
