import{_ as i,c as a,f as l,o as t}from"./app-LHpjaFTr.js";const s="/note/assets/5e8b43ecb5195d042f00000a-CFgXlZ58.png",n={};function o(r,e){return t(),a("div",null,e[0]||(e[0]=[l('<h1 id="缓存穿透-超大规模系统的不能承受之痛" tabindex="-1"><a class="header-anchor" href="#缓存穿透-超大规模系统的不能承受之痛"><span>缓存穿透：超大规模系统的不能承受之痛</span></a></h1><ul><li>对于像订单服务这类核心的业务，一个可行的方法是，我们启动一个更新订单缓存的服务，接收订单变更的 MQ 消息，然后更新 Redis 中缓存的订单数据。 <ul><li>必须保证整个消息链条的可靠性，不过好在现在的 MQ 集群，比如像 Kafka 或者 RocketMQ，它都有高可用和高可靠的保证机制，只要你正确配置好，是可以满足数据可靠性要求的。</li></ul></li></ul><h1 id="使用-binlog-实时更新-redis-缓存" tabindex="-1"><a class="header-anchor" href="#使用-binlog-实时更新-redis-缓存"><span>使用 Binlog 实时更新 Redis 缓存</span></a></h1><ul><li>负责更新缓存的服务，把自己伪装成一个 MySQL 的从节点，从 MySQL 接收 Binlog，解析 Binlog 之后，可以得到实时的数据变更信息，然后根据这个变更信息去更新 Redis 缓存。 <img src="'+s+'" alt=""></li><li>这个方案唯一的缺点是，实现订单缓存更新服务有点儿复杂，毕竟不像收消息，拿到的直接就是订单数据，解析 Binlog 还是挺麻烦的。</li><li>有很多开源的项目就提供了订阅和解析 MySQL Binlog 的功能，如Canal</li></ul>',4)]))}const d=i(n,[["render",o],["__file","17.html.vue"]]),m=JSON.parse('{"path":"/geektime/back-end-storage-practical-lession/17.html","title":"缓存穿透：超大规模系统的不能承受之痛","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1645920694000,"contributors":[{"name":"sindorei","email":"wupan1030@foxmail.com","commits":2,"url":"https://github.com/sindorei"}]},"filePathRelative":"geektime/back-end-storage-practical-lession/17.md"}');export{d as comp,m as data};
