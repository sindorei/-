import{_ as n,c as s,f as e,o}from"./app-LHpjaFTr.js";const l={};function c(t,a){return o(),s("div",null,a[0]||(a[0]=[e(`<h1 id="tapable" tabindex="-1"><a class="header-anchor" href="#tapable"><span>tapable</span></a></h1><ul><li><a href="https://github.com/webpack/tapable" target="_blank" rel="noopener noreferrer">github地址</a></li></ul><h1 id="用法" tabindex="-1"><a class="header-anchor" href="#用法"><span>用法</span></a></h1><ul><li>所有的Hook构造函数都采用一个可选参数，该参数是字符串形式的参数名称的列表。</li><li>根据Hook Type不同它们的实例有<code>tap</code>、<code>tapAsync</code>、<code>tapPromise</code>、<code>intercept</code>、<code>call</code>、<code>callAsync</code>、<code>promise</code>等方法</li></ul><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">const</span> <span class="token punctuation">{</span> SyncHook <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;tapable&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> syncHookTest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SyncHook</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">&#39;name&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">syncHookTest<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">&#39;go&#39;</span><span class="token punctuation">,</span><span class="token parameter">n</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token string">&quot; go&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line">syncHookTest<span class="token punctuation">.</span><span class="token function">tap</span><span class="token punctuation">(</span><span class="token string">&#39;swift&#39;</span><span class="token punctuation">,</span><span class="token parameter">n</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token string">&quot; swift&quot;</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line"><span class="token function">syncHookTest</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&#39;张三&#39;</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="钩子类型-hook-types" tabindex="-1"><a class="header-anchor" href="#钩子类型-hook-types"><span>钩子类型（Hook Types）</span></a></h1><h2 id="按被注册插件的执行逻辑来分类" tabindex="-1"><a class="header-anchor" href="#按被注册插件的执行逻辑来分类"><span>按被注册插件的执行逻辑来分类</span></a></h2><ul><li>Basic hook <ul><li>名字中没有“Waterfall”, “Bail” 或 “Loop” 的Hook，触发时按照注册的插件顺序执行</li><li>如<code>SyncHook</code>、<code>AsyncParallelHook</code>、<code>AsyncSeriesHook</code></li></ul></li><li>Waterfall <ul><li>触发时按照注册的插件顺序执行， 且前一个插件的返回值，是后一个插件的入参</li><li>如<code>SyncWaterfallHook</code>，<code>AsyncSeriesWaterfallHook</code></li></ul></li><li>Bail <ul><li>触发时按照注册的插件顺序执行，当某个插件返回非<code>undefined</code>的值时，就不继续执行后续的插件</li><li>如：<code>SyncBailHook</code>，<code>AsyncSeriesBailHook</code></li></ul></li><li>Loop <ul><li>循环调用插件，直到所有的插件的返回值都是<code>undefined</code>。当某个插件返回非<code>undefined</code>时，从第一个开始重新调用。</li><li>如<code>SyncLoopHook</code></li></ul></li></ul><h2 id="按是否异步区分" tabindex="-1"><a class="header-anchor" href="#按是否异步区分"><span>按是否异步区分</span></a></h2><ul><li>Sync <ul><li>以<code>Sync</code>开头的</li><li>只能通过<code>tap(）</code>方法注册同步插件</li><li><code>call: (...args) =&gt; Result</code>方法触发</li></ul></li><li>Async <ul><li>可以通过<code>tap()</code>方法注册同步插件, <code>tapAsync(name: string | Tap, fn: (context?, ...args, callback: (err, result: Result) =&gt; void) =&gt; void) =&gt; void</code>注册callback-based的插件 以及<code>tapPromise()</code>注册promise-based 的插件(插件返回<code>Promise</code>)。</li><li>通过<code>callAsync: (...args, callback: (err, Result) =&gt; void) =&gt; void</code>方法触发，或者 <code>promise: (...args) =&gt; Promise&lt;Result&gt;</code> 触发</li><li>AsyncSeries <ul><li><code>AsyncSeries</code>开头</li><li>各插件按照注册顺序串行执行。会等待异步插件完成后再执行下一个。<code>tapAsync</code>注册的某个插件调用<code>callback</code>的第一个参数为<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy" target="_blank" rel="noopener noreferrer">Truthy</a>或promise<code>reject</code>则执行结束,不再继续执行后面的插件</li><li><code>AsyncSeriesBailHook</code> 按顺序某个插件 <code>callback</code>第一个参数Falsy第二个参数Truthy或promise<code>resolve</code> 则后面插件不再执行，结束</li><li>结束后调用<code>callAsync</code>的回调或promise的<code>then</code></li><li><code>tapAsync</code> 别忘记调用回调否则不知道异步是否结束</li></ul></li><li>AsyncParallel <ul><li>使用方式基本跟<code>AsyncSeries</code>类似，但是各插件是按注册顺序平行执行，不相互依赖（不会按注册顺序等待上一个异步插件完成后再执行下一个插件），某个插件抛出错误后不会影响下一个插件，所以没有Waterfall、Loop钩子</li><li><code>AsyncParallelBailHook</code> 都执行完成后，调用通知结束的回调，并按顺序将第一个有返回值（或失败的错误信息）通知到结果（<code>callAsync</code>的回调或promise的<code>then</code>）</li></ul></li></ul></li></ul><h1 id="interception-api" tabindex="-1"><a class="header-anchor" href="#interception-api"><span>interception API</span></a></h1><ul><li>call:<code>(...args) =&gt; void</code><ul><li>hook被调用时被调用(调<code>call()</code>,<code>callAsync()</code>,<code>promise()</code>时)</li></ul></li><li>tap: <code>(tap: Tap) =&gt; void</code><ul><li>hook的插件被调用时被调用</li><li>参数会拿到<code>Tap</code>对象，此对象不能被改变</li></ul></li><li>loop: <code>(...args) =&gt; void</code><ul><li>loop hook的插件被调用时被调用</li></ul></li><li>register: <code>(tap: Tap) =&gt; Tap | undefined </code><ul><li>插件用tap方法注册时被调用，参数中拿到的<code>Tap</code>对象可以被修改</li></ul></li></ul><h1 id="context" tabindex="-1"><a class="header-anchor" href="#context"><span>Context</span></a></h1><ul><li>插件和拦截器都可以往里面传一个上下文对象的参数，该对象可用于向后续插件和拦截器传递任意值。</li></ul><h1 id="hookmap" tabindex="-1"><a class="header-anchor" href="#hookmap"><span>HookMap</span></a></h1><h1 id="hook-hookmap-interface" tabindex="-1"><a class="header-anchor" href="#hook-hookmap-interface"><span>Hook/HookMap interface</span></a></h1><h1 id="multihook" tabindex="-1"><a class="header-anchor" href="#multihook"><span>MultiHook</span></a></h1>`,17)]))}const p=n(l,[["render",c],["__file","tapable.html.vue"]]),d=JSON.parse('{"path":"/frontend/engineering/webpack/tapable.html","title":"tapable","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"按被注册插件的执行逻辑来分类","slug":"按被注册插件的执行逻辑来分类","link":"#按被注册插件的执行逻辑来分类","children":[]},{"level":2,"title":"按是否异步区分","slug":"按是否异步区分","link":"#按是否异步区分","children":[]}],"git":{"updatedTime":1686103182000,"contributors":[{"name":"sindorei","email":"wupan1030@foxmail.com","commits":6,"url":"https://github.com/sindorei"}]},"filePathRelative":"frontend/engineering/webpack/tapable.md"}');export{p as comp,d as data};
