import{_ as s,c as a,f as p,o as e}from"./app-LHpjaFTr.js";const t={};function l(c,n){return e(),a("div",null,n[0]||(n[0]=[p(`<h1 id="tcp基础和客户端-服务器的实现" tabindex="-1"><a class="header-anchor" href="#tcp基础和客户端-服务器的实现"><span>tcp基础和客户端/服务器的实现</span></a></h1><h2 id="tcp-协议是什么" tabindex="-1"><a class="header-anchor" href="#tcp-协议是什么"><span>TCP 协议是什么？</span></a></h2><p>TCP 是一种面向连接的、可靠的、基于字节流的传输层全双工通信协议，因此，它有 4 个特点：面向连接、可靠、流式、全双工。下面我们详细讲解这些特性。</p><h2 id="面向连接的本质" tabindex="-1"><a class="header-anchor" href="#面向连接的本质"><span>面向连接的本质</span></a></h2><p>TCP 中的连接是一个虚拟的连接，本质上是主机在内存里记录了对端的信息，我们可以将连接理解为一个通信的凭证。如下图所示。</p><p>tu 11-1</p><p>那么如何建立连接呢？ TCP 的连接是通过三次握手建立的。</p><p>服务器首先需要监听一个端口。 客户端主动往服务器监听的端口发起一个 syn 包（第一次握手）。 当服务器所在操作系统收到一个 syn 包时，会先根据 syn 包里的目的 IP 和端口找到对应的监听 socket，如果找不到则回复 rst 包，如果找到则发送 ack 给客户端（第二次握手），并新建一个通信 socket 并插入到监听 socket 的连接中队列（具体的细节会随着不同版本的操作系统而变化。比如连接中队列和连接完成队列是一条队列还是两条队列，再比如是否使用了 syn cookie 技术来防止 syn flood 攻击，如果使用了，收到 syn 包的时候就不会创建 socket，而是收到第三次握手的包时再创建）。 客户端收到服务器的 ack 后，再次发送 ack 给服务器，客户端就完成三次握手进入连接建立状态了。 当服务器所在操作系统收到客户端的 ack 时（第三次握手），处于连接中队列的 socket 就会被移到连接完成队列中。 当操作系统完成了一个 TCP 连接，操作系统就会通知相应的进程，进程从连接完成队列中摘下一个已完成连接的 socket 结点，然后生成一个新的 fd，后续就可以在该 fd 上和对端通信。具体的流程如下图所示。</p><p>tu 11-2</p><p>完成三次握手后，客户端和服务器就可以进行数据通信了 。 操作系统收到数据包和收到 syn 包的流程不一样，操作系统会根据报文中的 IP 和端口找到处理该报文的通信 socket（而不是监听 socket），然后把数据包（操作系统实现中是一个 skb 结构体）挂到该通信 socket 的数据队列中，如下图所示。</p><p>tu 11-3</p><p>当应用层调用 read 读取该 socket 的数据时，操作系统会根据应用层所需大小，从一个或多个 skb 中返回对应的字节数。同样，写也是类似的流程，当应用层往 socket 写入数据时，操作系统不一定会立刻发送出去，而是会保存到写缓冲区中，然后根据复杂的 TCP 算法发送。</p><p>当两端完成通信后需要关闭连接，否则会浪费内存。 TCP 通过四次挥手实现连接的断开，第一次挥手可以由任意一端发起。前面讲过 TCP 是全双工的，所以除了通过四次挥手完成整个 TCP 连接的断开外，也可以实现半断开，比如客户端关闭写端表示不会再发送数据，但是仍然可以读取来自对端发送端数据。四次挥手的流程如下。</p><p>tu 11-4</p><h3 id="可靠" tabindex="-1"><a class="header-anchor" href="#可靠"><span>可靠</span></a></h3><p>TCP 发送数据时会先缓存一份到已发送待确认队列中，并启动一个超时重传计时器，如果一定时间内没有收到对端的确认 ack，则触发重传机制，直到收到 ack 或者重传次数达到阈值。以下是某个版本的操作系统关于重传次数达到阈值时的逻辑。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">// 重传次数达到阈值</span>
<span class="line">if (sk-&gt;retransmits &gt; TCP_RETR2) </span>
<span class="line">{</span>
<span class="line">    // 设置错误码，通知进程</span>
<span class="line">    sk-&gt;err = ETIMEDOUT;</span>
<span class="line">    sk-&gt;error_report(sk);</span>
<span class="line">    // 删除重传定时器</span>
<span class="line">    del_timer(&amp;sk-&gt;retransmit_timer);</span>
<span class="line">    // 修改 socket 为关闭状态</span>
<span class="line">    tcp_set_state(sk, TCP_CLOSE);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="流式协议的本质" tabindex="-1"><a class="header-anchor" href="#流式协议的本质"><span>流式协议的本质</span></a></h3><p>建立连接后，应用层就可以调用发送接口源源不断地发送数据。通常情况下，并不是每次调用发送接口，操作系统就直接把数据发送出去，这些数据的发送是由操作系统按照一定的算法去发送的。对操作系统来说，它看到的是字节流，它会按照 TCP 算法打包出一个个包发送到对端，所以当对端收到数据后，需要处理好数据边界的问题。</p><p>tu 11-5</p><p>从上图中可以看到，假设应用层发送了两个 HTTP 请求，操作系统在打包数据发送时可能的场景是第一个包里包括了 HTTP 请求 1 的全部数据和部分请求 2 的数据，所以当对端收到数据并进行解析时，就需要根据 HTTP 协议准确地解析出第一个 HTTP 请求对应的数据。</p><p>因为 TCP 的流式协议，所以基于 TCP 的应用层通常需要定义一个应用层协议，然后按照应用层协议实现对应的解析器，这样才能完成有效的数据通信，比如常用的 HTTP 协议。对比来说 UDP 是面向数据包的协议，当应用层把数据传递给 UDP 时，操作系统会直接打包发送出去（如果数据字节大小超过阈值则会报错）。</p><h3 id="全双工的本质" tabindex="-1"><a class="header-anchor" href="#全双工的本质"><span>全双工的本质</span></a></h3><p>刚才提到 TCP 是全双工的，全双工就是通信的两端都有一个发送队列和接收队列，可以同时发送和接收，互不影响。另外也可以选择关闭读端或者写端。</p><p>tu 11-6</p><h3 id="tcp-协议的使用" tabindex="-1"><a class="header-anchor" href="#tcp-协议的使用"><span>TCP 协议的使用</span></a></h3><p>了解了 TCP 的基础概念后，来看看如何使用 TCP 协议进行通信。TCP / IP 协议是由操作系统内核实现的，当我们需要使用 TCP 协议进行通信时，可以通过操作系统提供的系统调用来完成。首先看如何创建一个服务器（伪代码）</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">// 创建一个 socket（socket 表示通信的一端），但是还没有绑定地址信息</span>
<span class="line">const fd = socket();  </span>
<span class="line">// 绑定到具体的 IP 和端口，如果没有显式配置，则操作系统自己决定</span>
<span class="line">bind(fd, ip, port);  </span>
<span class="line">// 修改 socket 为监听状态，就可以接收 TCP 连接了</span>
<span class="line">listen(fd);  </span>
<span class="line">// 等待完成三次握手的连接，如果 fd 是阻塞的，则进程被阻塞</span>
<span class="line">const acceptedFd = accept(fd);  </span>
<span class="line">// 当收到一个 TCP 连接时，accept 会返回对应的连接，通过 fd 表示，然后进行数据通信</span>
<span class="line">read(acceptedFd);  </span>
<span class="line">write(acceptedFd, &#39;hello&#39;);  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们看一下这几个函数的作用。</p><p>socket：socket 函数用于从操作系统申请一个 socket 结构体，该结构体用于表示和对端通信的一个连接，但是目前它还没有绑定到具体的通信地址。因为 Linux 中万物皆文件，所以最后操作系统会返回一个 fd，fd 在操作系统中类似数据库的 id，操作系统底层维护了 fd 和对应的资源关系，比如网络、文件、管道等。后续调用操作系统的接口时，传入这个 fd 和相关的参数，操作系统就会根据 fd 操作对应的资源。在 TCP 中，socket 代表了一个虚拟的连接，它由源 IP、源端口、目的 IP和目的端口组成并唯一标识。 bind：bind 函数用于给 fd 对应的 socket 设置本端对应的地址（IP 和端口），对于服务器来说，通常需要显式调用 bind，这样客户端才知道通过哪个端口和服务器通信，如果没有显式设置，那么操作系统会选择一个随机的端口，然后再通过其他 API 获取操作系统为我们选择的端口。 listen：listen 函数用于修改 fd 对应的 socket 的状态为监听状态。只有监听状态的 socket 才可以接受客户端的连接。socket 可以分为两种，一种是监听型的，一种是通信型的，监听型的 socket 只负责接收连接，通信型的 socket 负责和客户端通信。 accept：accept 用于从操作系统中获取一个已经完成三次握手的连接，该函数默认会阻塞进程，直到有连接到来并完成三次握手。我们也可以调用其他函数修改 socket 为非阻塞模式，这样调用 accept 时，如果没有已完成三次握手的连接，操作系统不会阻塞进程，而是会返回一个错误码。 read：当操作系统收到对端发过来的数据时，会先把它保存到 socket 的接收缓冲区。当应用层调用 read 时，就会把队列中数据返回给应用层。 write：write 用于给服务器发送数据，不过通常并不是直接发送。因为这些数据只是保存到 socket 的发送缓冲区，底层会根据 TCP 协议决定什么时候发送数据。 执行完以上代码，就完成了一个服务器的启动，操作系统中的关系图如下所示。</p><p>tu 11-7</p><p>接下来看一下如何创建一个 TCP 客户端</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text" data-title="text"><pre><code><span class="line">const fd = socket(); </span>
<span class="line">// 绑定到具体的 IP 和端口，如果没有显式配置，则操作系统自己决定</span>
<span class="line">bind(fd, ip, port);  </span>
<span class="line">// 发起一个连接，IP 和 port 表示对端的地址，connect 默认会引起进程阻塞</span>
<span class="line">const connectRet = connect(fd, ip, port);  </span>
<span class="line">// 到这说明连接结束，如果 connectRet 为 0 说明成功，可以进行数据读写</span>
<span class="line">write(fd, &#39;hello&#39;);  </span>
<span class="line">read(fd);  </span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端比服务器稍微简单一点，看看这几个函数的作用。</p><p>socket：和服务器一样，客户端也需要申请一个 socket 用于和服务器通信。</p><p>bind：bind 函数用于给 fd 对应的 socket 设置本端对应的地址（IP 和端口）。和服务器不一样的是，客户端通常不需要调用 bind，操作系统会决定使用哪个地址作为客户端地址。</p><p>connect：connect 用于绑定服务器地址。当进程调用 connect 时，操作系统会执行三次握手，默认情况操作系统会阻塞进程，直到连接有结果，连接结果会通过 connect 返回值告诉调用方。如果三次握手成功，我们就可以开始读取 / 发送数据了。同样，我们也可以设置 socket 为非阻塞模式。这样发起连接时，操作系统会先返回一个错误码，我们可以借助事件驱动模块订阅 socket 的可写事件，等待可写事件触发时再通过其他系统调用函数来获取连接结果。</p><p>以上是 TCP 协议在底层的一些基础知识，Node.js 的 TCP 模块本质上是基于这些底层能力，再结合 V8 实现的。接下来，我们就来看看 Node.js 中是如何实现 TCP 模块的。</p><p>Node.js TCP 服务器的实现 启动服务器 在 Node.js 中，我们通常使用以下方式创建一个服务器。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// 创建一个 TCP Server</span></span>
<span class="line"><span class="token keyword">const</span> server <span class="token operator">=</span> net<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">socket</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 处理连接</span></span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line"><span class="token comment">// 监听端口，启动服务器</span></span>
<span class="line">server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用 net.createServer 可以创建一个服务器，然后拿到一个 Server 对象，接着调用 Server 对象的 listen 函数就可以启动一个 TCP 服务器了。下面来看一下具体的实现。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">createServer</span><span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> connectionListener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Server</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> connectionListener<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line"><span class="token punctuation">}</span>  </span>
<span class="line">  </span>
<span class="line"><span class="token keyword">function</span> <span class="token function">Server</span><span class="token punctuation">(</span><span class="token parameter">options<span class="token punctuation">,</span> connectionListener</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token function">EventEmitter</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 服务器收到的连接数，可以通过 maxConnections 限制并发连接数  </span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>_connections <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// C++ 层的对象，真正实现 TCP 功能的地方</span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>_handle <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 服务器下的连接是否允许半关闭，下一节课详细讲解  </span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>allowHalfOpen <span class="token operator">=</span> options<span class="token punctuation">.</span>allowHalfOpen <span class="token operator">||</span> <span class="token boolean">false</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 有连接时是否注册可读事件，如果该 socket 是交给其他进程处理的话可以设置为 true </span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>pauseOnConnect <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>options<span class="token punctuation">.</span>pauseOnConnect<span class="token punctuation">;</span>  </span>
<span class="line"><span class="token punctuation">}</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>createServer 返回的是一个一般的 JS 对象，继续看一下 listen 函数的逻辑，listen 函数逻辑很繁琐，但是原理大致是一样的，所以我们只讲解常用的情况。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token class-name">Server</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">listen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token comment">/*</span>
<span class="line">    处理入参，listen 可以接收很多种格式的参数，</span>
<span class="line">    假设我们这里只传了 8888 端口号</span>
<span class="line">  */</span></span>
<span class="line">    <span class="token keyword">const</span> normalized <span class="token operator">=</span> <span class="token function">normalizeArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token comment">//  normalized = [{port: 8888}, null];  </span></span>
<span class="line">    <span class="token keyword">const</span> options <span class="token operator">=</span> normalized<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token comment">// 监听成功后的回调 </span></span>
<span class="line">    <span class="token keyword">const</span> cb <span class="token operator">=</span> normalized<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  </span>
<span class="line">    </span>
<span class="line">    <span class="token comment">// listen 成功后执行的回调  </span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>cb <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">once</span><span class="token punctuation">(</span><span class="token string">&#39;listening&#39;</span><span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token function">listenIncluster</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> </span>
<span class="line">                    <span class="token keyword">null</span><span class="token punctuation">,</span> </span>
<span class="line">                    options<span class="token punctuation">.</span>port <span class="token operator">|</span> <span class="token number">0</span><span class="token punctuation">,</span> </span>
<span class="line">                    <span class="token number">4</span><span class="token punctuation">,</span>      </span>
<span class="line">                    <span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  </span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>listen 处理了入参后，接着调用了 listenIncluster。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">listenIncluster</span><span class="token punctuation">(</span><span class="token parameter">server<span class="token punctuation">,</span> </span>
<span class="line">                         address<span class="token punctuation">,</span> </span>
<span class="line">                         port<span class="token punctuation">,</span> </span>
<span class="line">                         addressType<span class="token punctuation">,</span>      </span>
<span class="line">                         backlog<span class="token punctuation">,</span> </span>
<span class="line">                         fd<span class="token punctuation">,</span> </span>
<span class="line">                         exclusive</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  exclusive <span class="token operator">=</span> <span class="token operator">!</span><span class="token operator">!</span>exclusive<span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>cluster <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> cluster <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&#39;cluster&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>cluster<span class="token punctuation">.</span>isMaster <span class="token operator">||</span> exclusive<span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">    server<span class="token punctuation">.</span><span class="token function">_listen2</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> port<span class="token punctuation">,</span> addressType<span class="token punctuation">,</span> backlog<span class="token punctuation">,</span> fd<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token punctuation">}</span>  </span>
<span class="line"><span class="token punctuation">}</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们只分析在主进程创建服务器的情况，子进程中创建服务器的逻辑在 Cluster 模块分析。listenIncluster 中执行了 _listen2，_listen2 对应的函数是 setupListenHandle。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">setupListenHandle</span><span class="token punctuation">(</span><span class="token parameter">address<span class="token punctuation">,</span> port<span class="token punctuation">,</span> addressType<span class="token punctuation">,</span> backlog<span class="token punctuation">,</span> fd</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">    <span class="token comment">// 通过 C++ 层导出的 API 创建一个对象，该对象关联了 C++ 层的 TCPWrap 对象</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>_handle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TCP</span><span class="token punctuation">(</span>TCPConstants<span class="token punctuation">.</span><span class="token constant">SERVER</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 创建 socket 并绑定地址到 socket 中</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_handle</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">    <span class="token comment">// 有完成三次握手的连接时执行的回调  </span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>_handle<span class="token punctuation">.</span>onconnection <span class="token operator">=</span> onconnection<span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token comment">// 互相关联</span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>_handle<span class="token punctuation">[</span>owner_symbol<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 执行 C++ 层 listen  </span></span>
<span class="line">    <span class="token keyword">this</span><span class="token punctuation">.</span>_handle<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>backlog <span class="token operator">||</span> <span class="token number">511</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token comment">// 触发 listen 回调  </span></span>
<span class="line">    <span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">[</span>async_id_symbol<span class="token punctuation">]</span><span class="token punctuation">,</span> emitListeningNT<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line"><span class="token punctuation">}</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>setupListenHandle 的逻辑如下。</p><p>调用 new TCP 创建一个 handle（new TCP 对象关联了 C++ 层的 TCPWrap 对象）。 保存处理连接的函数 onconnection，当有连接时被执行。 调用了 bind 绑定地址到 socket。 调用 listen 函数修改 socket 状态为监听状态。 首先看看 new TCP 做了什么。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">void TCPWrap::New(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</span>
<span class="line">  new TCPWrap(env, args.This(), ...);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line">TCPWrap::TCPWrap(Environment* env, Local&lt;Object&gt; object, ProviderType provider)</span>
<span class="line">    : ConnectionWrap(env, object, provider) {</span>
<span class="line">  // 初始化一个 tcp handle</span>
<span class="line">  int r = uv_tcp_init(env-&gt;event_loop(), &amp;handle_);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>new TCP 本质上是创建一个 TCP 层的 TCPWrap 对象，并初始化了 Libuv 的数据结构 uv_tcp_t（TCPWrap 是对 Libuv uv_tcp_t 的封装）。</p><p>接着看 bind，通过前面的学习，我们知道这时候会调用 C++ 层的 Bind。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">template &lt;typename T&gt;</span>
<span class="line">void TCPWrap::Bind(...) {</span>
<span class="line">  // 通过 JS 对象拿到关联的 C++ TCPWrap 对象</span>
<span class="line">  TCPWrap* wrap;</span>
<span class="line">  ASSIGN_OR_RETURN_UNWRAP(&amp;wrap,</span>
<span class="line">                          args.Holder(),</span>
<span class="line">                          args.GetReturnValue().Set(UV_EBADF));</span>
<span class="line">  // 通过 JS 传入的地址信息直接调用 Libuv</span>
<span class="line">  uv_tcp_bind(&amp;wrap-&gt;handle_,</span>
<span class="line">              reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr),</span>
<span class="line">              flags);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Bind 函数的逻辑很简单，直接调用了 Libuv 函数。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">uv_tcp_bind</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token function">uv__tcp_bind</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addrlen<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">uv__tcp_bind</span><span class="token punctuation">(</span><span class="token class-name">uv_tcp_t</span><span class="token operator">*</span> tcp<span class="token punctuation">,</span></span>
<span class="line">                 <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span></span>
<span class="line">                 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> addrlen<span class="token punctuation">,</span></span>
<span class="line">                 <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 创建一个 socket，并把返回的 fd 保存到 tcp 结构体中</span></span>
<span class="line">  <span class="token function">maybe_new_socket</span><span class="token punctuation">(</span>tcp<span class="token punctuation">,</span> addr<span class="token operator">-&gt;</span>sa_family<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  on <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 默认设置了 SO_REUSEADDR 属性，后面具体分析</span></span>
<span class="line">  <span class="token function">setsockopt</span><span class="token punctuation">(</span>tcp<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> SOL_SOCKET<span class="token punctuation">,</span> SO_REUSEADDR<span class="token punctuation">,</span> <span class="token operator">&amp;</span>on<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>on<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 绑定地址信息到 socket</span></span>
<span class="line">  <span class="token function">bind</span><span class="token punctuation">(</span>tcp<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>uv__tcp_bind 创建了一个 TCP socket 然后把地址信息保存到该 socket 中，另外 Libuv 默认设置了 SO_REUSEADDR 标记，这个的意义我们在下节课分析。</p><p>执行 bind 绑定了地址信息后就继续调用 listen 把 socket 变成监听状态，C++ 层代码和 Bind 的差不多，就不再分析，直接看 Libuv 的代码。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">uv_listen</span><span class="token punctuation">(</span><span class="token class-name">uv_stream_t</span><span class="token operator">*</span> stream<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">,</span> uv_connection_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token function">uv_tcp_listen</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">uv_tcp_t</span><span class="token operator">*</span><span class="token punctuation">)</span>stream<span class="token punctuation">,</span> backlog<span class="token punctuation">,</span> cb<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">int</span> <span class="token function">uv_tcp_listen</span><span class="token punctuation">(</span><span class="token class-name">uv_tcp_t</span><span class="token operator">*</span> tcp<span class="token punctuation">,</span> <span class="token keyword">int</span> backlog<span class="token punctuation">,</span> uv_connection_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">static</span> <span class="token keyword">int</span> single_accept <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">unsigned</span> <span class="token keyword">long</span> flags<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">int</span> err<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>single_accept <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> val <span class="token operator">=</span> <span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">&quot;UV_TCP_SINGLE_ACCEPT&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    single_accept <span class="token operator">=</span> <span class="token punctuation">(</span>val <span class="token operator">!=</span> <span class="token constant">NULL</span> <span class="token operator">&amp;&amp;</span> <span class="token function">atoi</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line">  <span class="token comment">// 有连接时是否连续接收，或者间歇性处理，见后面分析</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>single_accept<span class="token punctuation">)</span></span>
<span class="line">    tcp<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> UV_HANDLE_TCP_SINGLE_ACCEPT<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 设置 flags 到 handle 上，因为已经创建了 socket</span></span>
<span class="line">  <span class="token function">maybe_new_socket</span><span class="token punctuation">(</span>tcp<span class="token punctuation">,</span> AF_INET<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">listen</span><span class="token punctuation">(</span>tcp<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">.</span>fd<span class="token punctuation">,</span> backlog<span class="token punctuation">)</span></span>
<span class="line">  <span class="token comment">// 保存回调，有连接到来时被 Libuv 执行</span></span>
<span class="line">  tcp<span class="token operator">-&gt;</span>connection_cb <span class="token operator">=</span> cb<span class="token punctuation">;</span></span>
<span class="line">  tcp<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> UV_HANDLE_BOUND<span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 有连接来时的处理函数，该函数再执行上面的 connection_cb</span></span>
<span class="line">  tcp<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">.</span>cb <span class="token operator">=</span> uv__server_io<span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 注册可读事件，等待连接到来</span></span>
<span class="line">  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>tcp<span class="token operator">-&gt;</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>tcp<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>uv_tcp_listen 首先调用了 listen 函数修改 socket 状态为监听状态，这样才能接收 TCP 连接，接着保存了 C++ 层的回调，并设置 Libuv 层的回调，最后注册可读事件等待 TCP 连接的到来。这里需要注意两个回调函数的执行顺序，当有 TCP 连接到来时 Libuv 会执行 uv__server_io，在 uv__server_io 里再执行 C++ 层的回调 cb。</p><p>至此，服务器就启动了。</p><h3 id="处理连接" tabindex="-1"><a class="header-anchor" href="#处理连接"><span>处理连接</span></a></h3><p>当有三次握手的连接完成时，操作系统会新建一个通信的 socket，并通知 Libuv，Libuv 会执行 uv__server_io。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">uv__server_io</span><span class="token punctuation">(</span><span class="token class-name">uv_loop_t</span><span class="token operator">*</span> loop<span class="token punctuation">,</span> <span class="token class-name">uv__io_t</span><span class="token operator">*</span> w<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> events<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token class-name">uv_stream_t</span><span class="token operator">*</span> stream<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">int</span> err<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  stream <span class="token operator">=</span> <span class="token function">container_of</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> <span class="token class-name">uv_stream_t</span><span class="token punctuation">,</span> io_watcher<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"> </span>
<span class="line">  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 回调了可能关闭了 server，所以需要实时判断</span></span>
<span class="line">  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// 摘取一个 TCP 连接，成功的话，err 保存了对应的 fd</span></span>
<span class="line">    err <span class="token operator">=</span> <span class="token function">uv__accept</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>stream<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 保存 fd 在 accepted_fd，等待处理</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span>accepted_fd <span class="token operator">=</span> err<span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 执行回调</span></span>
<span class="line">    stream<span class="token operator">-&gt;</span><span class="token function">connection_cb</span><span class="token punctuation">(</span>stream<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 如果回调里没有处理该 accepted_fd，则注销可读事件、先不处理新的连接</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>accepted_fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token function">uv__io_stop</span><span class="token punctuation">(</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>stream<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">,</span> POLLIN<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token keyword">return</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">    <span class="token comment">// 设置了 UV_HANDLE_TCP_SINGLE_ACCEPT 则进入睡眠，让其他进程有机会参与处理</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>type <span class="token operator">==</span> UV_TCP <span class="token operator">&amp;&amp;</span></span>
<span class="line">        <span class="token punctuation">(</span>stream<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> UV_HANDLE_TCP_SINGLE_ACCEPT<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">      <span class="token keyword">struct</span> <span class="token class-name">timespec</span> timeout <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line">      <span class="token function">nanosleep</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>timeout<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line">  <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>uv__server_io 中通过 uv__accept 从操作系统中摘取一个完成连接的 TCP socket 并拿到一个 fd ，接着保存到 accepted_fd 中并执行 connection_cb 回调。</p><p>此外，我们需要注意 UV_HANDLE_TCP_SINGLE_ACCEPT 标记。因为可能有多个进程监听同一个端口，当多个连接到来时，多个进程可能会竞争处理这些连接（惊群问题）。这样一来，首先被调度的进程可能会直接处理所有的连接，导致负载不均衡。通过 UV_HANDLE_TCP_SINGLE_ACCEPT 标记，可以在通知进程接收连接时，每接收到一个后先睡眠一段时间，让其他进程也有机会接收连接，一定程度解决负载不均衡的问题，不过这个逻辑最近被去掉了，Libuv 维护者 bnoordhuis 的理由是，第二次调用 uv__accept 时有 99.9% 的概念会返回 EAGAIN，那就是没有更多的连接可以处理，这样额外调用 uv__accept 带来的系统调用开销是比较可观的，有兴趣的可以参考这个 <a href="https://github.com/libuv/libuv/pull/3696" target="_blank" rel="noopener noreferrer">PR</a>。</p><p>接着我们看看 connection_cb，connection_cb 对应的是 C++ 层的 OnConnection。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">// WrapType 为 TCPWrap，UVType 为 uv_tcp_t</span>
<span class="line">template &lt;typename WrapType, typename UVType&gt;  </span>
<span class="line">void ConnectionWrap&lt;WrapType, UVType&gt;::OnConnection(uv_stream_t* handle, int status) {  </span>
<span class="line">    // HandleWrap 中保存了 handle 和 TCPWrap 的关系，这里取出来使用               </span>
<span class="line">    WrapType* wrap_data = static_cast&lt;WrapType*&gt;(handle-&gt;data);  </span>
<span class="line">    Environment* env = wrap_data-&gt;env();  </span>
<span class="line">    Local&lt;Value&gt; argv[] = {  </span>
<span class="line">        Integer::New(env-&gt;isolate(), status),  </span>
<span class="line">        Undefined(env-&gt;isolate())  </span>
<span class="line">    };  </span>
<span class="line">    </span>
<span class="line">    // 新建一个表示和客户端通信的对象，和 JS 层执行 new TCP 一样 </span>
<span class="line">    Local&lt;Object&gt; client_obj = WrapType::Instantiate(env,wrap_data,WrapType::SOCKET);  </span>
<span class="line">    WrapType* wrap;  </span>
<span class="line">    // 从 client_obj 中取出关联的 TCPWrap 对象存到 wrap 中 </span>
<span class="line">    ASSIGN_OR_RETURN_UNWRAP(&amp;wrap, client_obj);  </span>
<span class="line">    // 拿到 TCPWrap 中的 uv_tcp_t 结构体，再转成 uv_stream_t，因为它们类似父类和子类的关系</span>
<span class="line">    uv_stream_t* client_handle = reinterpret_cast&lt;uv_stream_t*&gt;(&amp;wrap-&gt;handle_);  </span>
<span class="line">    // 把通信 fd 存储到 client_handle 中  </span>
<span class="line">    uv_accept(handle, client_handle);</span>
<span class="line">    argv[1] = client_obj;  </span>
<span class="line">    // 回调上层的 onconnection 函数  </span>
<span class="line">    wrap_data-&gt;MakeCallback(env-&gt;onconnection_string(), arraysize(argv), argv);  </span>
<span class="line">}  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当建立了新连接时，操作系统会新建一个 socket。同样，在 Node.js 层，也会通过 Instantiate 函数新建一个对应的对象表示和客户端的通信。结构如下所示。</p><p>tu 11-8</p><p>Instantiate 代码如下所示。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">MaybeLocal&lt;Object&gt; TCPWrap::Instantiate(Environment* env,</span>
<span class="line">                                        AsyncWrap* parent,</span>
<span class="line">                                        TCPWrap::SocketType type) {</span>
<span class="line">  // 拿到导出到 JS 层的 TCP 构造函数（缓存在env中）</span>
<span class="line">  Local&lt;Function&gt; constructor = env-&gt;tcp_constructor_template()</span>
<span class="line">                                    -&gt;GetFunction(env-&gt;context())</span>
<span class="line">                                    .ToLocalChecked();</span>
<span class="line">  Local&lt;Value&gt; type_value = Int32::New(env-&gt;isolate(), type);</span>
<span class="line">  // 相当于我们在 JS 层调用 new TCP() 时拿到的对象</span>
<span class="line">  return handle_scope.EscapeMaybe(</span>
<span class="line">      constructor-&gt;NewInstance(env-&gt;context(), 1, &amp;type_value));</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>新建完和对端通信的对象后，接着调用 uv_accept 消费刚才保存在 accepted_fd 中的 fd，并把对应的 fd 保存到 C++ TCPWrap 对象的 uv_tcp_t 结构体中。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">int uv_accept(uv_stream_t* server, uv_stream_t* client) {</span>
<span class="line">  int err;</span>
<span class="line">  // 把 accepted_fd 保存到 client 中</span>
<span class="line">  uv__stream_open(client,</span>
<span class="line">                  server-&gt;accepted_fd,</span>
<span class="line">                  UV_HANDLE_READABLE | UV_HANDLE_WRITABLE);</span>
<span class="line">  // 处理了，重置该字段</span>
<span class="line">  server-&gt;accepted_fd = -1;</span>
<span class="line">  // 保证注册了可读事件，继续处理新的连接</span>
<span class="line">  uv__io_start(server-&gt;loop, &amp;server-&gt;io_watcher, POLLIN);</span>
<span class="line">  return err;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>C++ 层拿到一个新的对象并且保存了 fd 到对象后，接着回调 JS 层的 onconnection。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// clientHandle 代表一个和客户端建立 TCP 连接的实体  </span></span>
<span class="line"><span class="token keyword">function</span> <span class="token function">onconnection</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> clientHandle</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token keyword">const</span> handle <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token keyword">const</span> self <span class="token operator">=</span> handle<span class="token punctuation">.</span>owner<span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 建立过多，关掉  </span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>self<span class="token punctuation">.</span>maxConnections <span class="token operator">&amp;&amp;</span> self<span class="token punctuation">.</span>_connections <span class="token operator">&gt;=</span> self<span class="token punctuation">.</span>maxConnections<span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">    clientHandle<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token keyword">return</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token punctuation">}</span>  </span>
<span class="line">  <span class="token comment">// 新建一个 socket 用于通信  </span></span>
<span class="line">  <span class="token keyword">const</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  </span>
<span class="line">    <span class="token literal-property property">handle</span><span class="token operator">:</span> clientHandle<span class="token punctuation">,</span>  </span>
<span class="line">    <span class="token literal-property property">allowHalfOpen</span><span class="token operator">:</span> self<span class="token punctuation">.</span>allowHalfOpen<span class="token punctuation">,</span>  </span>
<span class="line">    <span class="token literal-property property">pauseOnCreate</span><span class="token operator">:</span> self<span class="token punctuation">.</span>pauseOnConnect  </span>
<span class="line">  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 服务器的连接数加一  </span></span>
<span class="line">  self<span class="token punctuation">.</span>_connections<span class="token operator">++</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 触发用户层连接事件  </span></span>
<span class="line">  self<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&#39;connection&#39;</span><span class="token punctuation">,</span> socket<span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line"><span class="token punctuation">}</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 JS 层也会封装一个 Socket 对象用于管理和客户端的通信，整体的关系如下。</p><p>tu 11-9</p><p>接着触发 connection 事件，剩下的事情就是应用层处理了。</p><h2 id="node-js-tcp-客户端的实现" tabindex="-1"><a class="header-anchor" href="#node-js-tcp-客户端的实现"><span>Node.js TCP 客户端的实现</span></a></h2><p>了解了服务器的实现后，接下来看看客户端的实现。在 Node.js 中，我们可以通过 net.connect 发起 TCP 连接，下面具体来分析下 connect 函数。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token comment">// 处理参数  </span></span>
<span class="line">  <span class="token keyword">const</span> normalized <span class="token operator">=</span> <span class="token function">normalizeArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token keyword">const</span> options <span class="token operator">=</span> normalized<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 申请一个 socket 表示一个客户端  </span></span>
<span class="line">  <span class="token keyword">const</span> socket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Socket</span><span class="token punctuation">(</span>options<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token comment">// 设置超时，超时后会触发 timeout，用户可以自定义处理超时逻辑</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">    socket<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token punctuation">}</span>  </span>
<span class="line">  <span class="token comment">// 调用 socket 的 connect  </span></span>
<span class="line">  <span class="token keyword">return</span> socket<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>normalized<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从代码中可以看到，connect 函数是对 Socket 对象的封装，Socket 表示一个通信的端点。我们主要分析 new Socket 和 Socket 的 connect。那么，新建一个客户端 Socket 对象都做了什么事情呢？</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">Socket</span><span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 是否正在建立连接，即三次握手中  </span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>connecting <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 对应的底层 handle，比如 TCPWrap 对象</span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">[</span>kHandle<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 是否允许半开关，即收到对端 fin 包后是否默认也发送 fin 包给对端（四次挥手）来断开连接</span></span>
<span class="line">  options<span class="token punctuation">.</span>allowHalfOpen <span class="token operator">=</span> <span class="token function">Boolean</span><span class="token punctuation">(</span>options<span class="token punctuation">.</span>allowHalfOpen<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// Socket 是全双工流</span></span>
<span class="line">  stream<span class="token punctuation">.</span><span class="token function">Duplex</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 注册读端关闭的回调 </span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">&#39;end&#39;</span><span class="token punctuation">,</span> onReadableStreamEnd<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Socket 是对 C++ 模块 TCPWrap 的封装，主要初始化了一些属性和监听一些事件，这里简单列了一些字段。创建了一个 socket 后，接着看一下 socket 的 connect 函数。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token comment">// 建立连接，即三次握手  </span></span>
<span class="line"><span class="token class-name">Socket</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">connect</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token keyword">const</span> normalized <span class="token operator">=</span> <span class="token function">normalizeArgs</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">const</span> options <span class="token operator">=</span> normalized<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token keyword">const</span> cb <span class="token operator">=</span> normalized<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </span>
<span class="line">  <span class="token comment">// 创建一个 C++ 层的 TCPWrap 对象表示客户端  </span></span>
<span class="line">  <span class="token keyword">this</span><span class="token punctuation">.</span>_handle <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TCP</span><span class="token punctuation">(</span>TCPConstants<span class="token punctuation">.</span><span class="token constant">SOCKET</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line">  <span class="token comment">// 设置 handle 关联的 JS socket 对象</span></span>
<span class="line">  self<span class="token punctuation">.</span>_handle<span class="token punctuation">[</span>owner_symbol<span class="token punctuation">]</span> <span class="token operator">=</span> self<span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 有数据可读时的回调 </span></span>
<span class="line">  self<span class="token punctuation">.</span>_handle<span class="token punctuation">.</span>onread <span class="token operator">=</span> onStreamRead<span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 可能需要 DNS 解析，解析成功再发起连接  </span></span>
<span class="line">  <span class="token function">lookupAndConnect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> options<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>  </span>
<span class="line"><span class="token punctuation">}</span><span class="token punctuation">;</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>connect 函数主要是 3 个逻辑。</p><p>首先通过 new TCP() 创建一个底层的 C++ 对象。 设置可读回调。 做 DNS 解析（如果需要的话），然后发起三次握手。 new TCP 刚才已经分析过了，所以这里就不再分析，直接看 lookupAndConnect。lookupAndConnect 主要是对参数进行校验，如果传的是域名，就进行 DNS 解析，否则就不解析。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">lookupAndConnect</span><span class="token punctuation">(</span><span class="token parameter">self<span class="token punctuation">,</span> options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">const</span> <span class="token punctuation">{</span> localAddress<span class="token punctuation">,</span> localPort <span class="token punctuation">}</span> <span class="token operator">=</span> options<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">const</span> host <span class="token operator">=</span> options<span class="token punctuation">.</span>host <span class="token operator">||</span> <span class="token string">&#39;localhost&#39;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">let</span> <span class="token punctuation">{</span> port <span class="token punctuation">}</span> <span class="token operator">=</span> options<span class="token punctuation">;</span></span>
<span class="line">    port <span class="token operator">|=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token comment">// 是 IP，则不需要 DNS 解析，直接连接</span></span>
<span class="line">    <span class="token keyword">const</span> addressType <span class="token operator">=</span> <span class="token function">isIP</span><span class="token punctuation">(</span>host<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>addressType<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">internalConnect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> addressType<span class="token punctuation">,</span> localAddress<span class="token punctuation">,</span> localPort<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">lookup</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> dnsopts<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">emitLookup</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> ip<span class="token punctuation">,</span> addressType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">          <span class="token function">internalConnect</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ip<span class="token punctuation">,</span> port<span class="token punctuation">,</span> addressType<span class="token punctuation">,</span> localAddress<span class="token punctuation">,</span> localPort<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>最终拿到 IP 后就可以发起连接了。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">internalConnect</span><span class="token punctuation">(</span>  </span>
<span class="line">  self<span class="token punctuation">,</span>   </span>
<span class="line">  <span class="token comment">// 需要连接的服务器的 IP、端口  </span></span>
<span class="line">  address<span class="token punctuation">,</span>   </span>
<span class="line">  port<span class="token punctuation">,</span>   </span>
<span class="line">  addressType<span class="token punctuation">,</span>   </span>
<span class="line">  <span class="token comment">/*</span>
<span class="line">      用于和对端连接的本地 IP、端口，</span>
<span class="line">      如果不设置，则操作系统自己决定  </span>
<span class="line">  */</span></span>
<span class="line">  localAddress<span class="token punctuation">,</span>   </span>
<span class="line">  localPort<span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">  <span class="token keyword">var</span> err<span class="token punctuation">;</span>  </span>
<span class="line">   <span class="token comment">/*</span>
<span class="line">      如果传了本地的地址或端口，则 TCP 连接中的源 IP</span>
<span class="line">      和端口就是传的，否则由操作系统自己选</span>
<span class="line">  */</span>  </span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>localAddress <span class="token operator">||</span> localPort<span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">      <span class="token comment">// IP v4  </span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>addressType <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">      localAddress <span class="token operator">=</span> localAddress <span class="token operator">||</span> <span class="token string">&#39;0.0.0.0&#39;</span><span class="token punctuation">;</span>  </span>
<span class="line">      <span class="token comment">// 绑定本地地址和端口到 handle，即使用本主机的哪个 IP 和端口发起连接</span></span>
<span class="line">      err <span class="token operator">=</span> self<span class="token punctuation">.</span><span class="token function">_handle</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>localAddress<span class="token punctuation">,</span> localPort<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>addressType <span class="token operator">===</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">      localAddress <span class="token operator">=</span> localAddress <span class="token operator">||</span> <span class="token string">&#39;::&#39;</span><span class="token punctuation">;</span>  </span>
<span class="line">      err <span class="token operator">=</span> self<span class="token punctuation">.</span>_handle<span class="token punctuation">.</span><span class="token function">bind6</span><span class="token punctuation">(</span>localAddress<span class="token punctuation">,</span> localPort<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token punctuation">}</span>   </span>
<span class="line">  <span class="token punctuation">}</span>  </span>
<span class="line">    <span class="token comment">// 对端的地址信息</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>addressType <span class="token operator">===</span> <span class="token number">6</span> <span class="token operator">||</span> addressType <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  </span>
<span class="line">    <span class="token comment">// 新建一个请求对象，C++ 层定义  </span></span>
<span class="line">    <span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TCPConnectWrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token comment">// 设置一些列属性  </span></span>
<span class="line">    req<span class="token punctuation">.</span>oncomplete <span class="token operator">=</span> afterConnect<span class="token punctuation">;</span>  </span>
<span class="line">    req<span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>  </span>
<span class="line">    req<span class="token punctuation">.</span>port <span class="token operator">=</span> port<span class="token punctuation">;</span>  </span>
<span class="line">    req<span class="token punctuation">.</span>localAddress <span class="token operator">=</span> localAddress<span class="token punctuation">;</span>  </span>
<span class="line">    req<span class="token punctuation">.</span>localPort <span class="token operator">=</span> localPort<span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token comment">// 调用底层对应的函数  </span></span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>addressType <span class="token operator">===</span> <span class="token number">4</span><span class="token punctuation">)</span>  </span>
<span class="line">      err <span class="token operator">=</span> self<span class="token punctuation">.</span>_handle<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">    <span class="token keyword">else</span>  </span>
<span class="line">      err <span class="token operator">=</span> self<span class="token punctuation">.</span>_handle<span class="token punctuation">.</span><span class="token function">connect6</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line">  <span class="token punctuation">}</span>  </span>
<span class="line"><span class="token punctuation">}</span>  </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的代码比较多，主要的逻辑是 bind 和 connect。bind 函数前面已经讲解过了，它就是给 socket 设置客户端 IP 和端口的值。我们主要来分析 connect，把 connect 这段逻辑拎出来。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">const</span> req <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TCPConnectWrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span>
<span class="line"><span class="token comment">// 设置一些列属性  </span></span>
<span class="line">req<span class="token punctuation">.</span>oncomplete <span class="token operator">=</span> afterConnect<span class="token punctuation">;</span>  </span>
<span class="line">req<span class="token punctuation">.</span>address <span class="token operator">=</span> address<span class="token punctuation">;</span>  </span>
<span class="line">req<span class="token punctuation">.</span>port <span class="token operator">=</span> port<span class="token punctuation">;</span>  </span>
<span class="line">req<span class="token punctuation">.</span>localAddress <span class="token operator">=</span> localAddress<span class="token punctuation">;</span>  </span>
<span class="line">req<span class="token punctuation">.</span>localPort <span class="token operator">=</span> localPort<span class="token punctuation">;</span>  </span>
<span class="line"><span class="token comment">// 调用底层对应的函数  </span></span>
<span class="line">self<span class="token punctuation">.</span>_handle<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> address<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>TCPConnectWrap 是 C++ 层提供的类，用来表示一个 TCP 连接请求的上下文，connect 对应C++ 层的 Conenct。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">void TCPWrap::Connect(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {</span>
<span class="line">  int port = static_cast&lt;int&gt;(args[2].As&lt;Uint32&gt;()-&gt;Value());</span>
<span class="line">  Connect&lt;sockaddr_in&gt;(args, [port](const char* ip_address, sockaddr_in* addr) {</span>
<span class="line">      return uv_ip4_addr(ip_address, port, addr);</span>
<span class="line">  });</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里把 JS 层传入的 IP 和端口取出来，继续调另一个 Connect。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">template &lt;typename T&gt;</span>
<span class="line">void TCPWrap::Connect(const FunctionCallbackInfo&lt;Value&gt;&amp; args,</span>
<span class="line">    std::function&lt;int(const char* ip_address, T* addr)&gt; uv_ip_addr) {</span>
<span class="line">    </span>
<span class="line">  Environment* env = Environment::GetCurrent(args);</span>
<span class="line"></span>
<span class="line">  TCPWrap* wrap;</span>
<span class="line">  // 拿到 C++ 层的 TCPWrap</span>
<span class="line">  ASSIGN_OR_RETURN_UNWRAP(&amp;wrap,</span>
<span class="line">                          args.Holder(),</span>
<span class="line">                          args.GetReturnValue().Set(UV_EBADF));</span>
<span class="line"></span>
<span class="line">  Local&lt;Object&gt; req_wrap_obj = args[0].As&lt;Object&gt;();</span>
<span class="line">  node::Utf8Value ip_address(env-&gt;isolate(), args[1]);</span>
<span class="line"></span>
<span class="line">  T addr;</span>
<span class="line">  int err = uv_ip_addr(*ip_address, &amp;addr);</span>
<span class="line"></span>
<span class="line">  if (err == 0) {</span>
<span class="line">    // req_wrap 和 req_wrap_obj 互相关联</span>
<span class="line">    ConnectWrap* req_wrap = new ConnectWrap(env, req_wrap_obj, ...);</span>
<span class="line">    // 发起请求，即调用 uv_tcp_connect 发起一个 TCP 连接</span>
<span class="line">    err = req_wrap-&gt;Dispatch(uv_tcp_connect,</span>
<span class="line">                             &amp;wrap-&gt;handle_,</span>
<span class="line">                             reinterpret_cast&lt;const sockaddr*&gt;(&amp;addr),</span>
<span class="line">                             // 连接结束后执行的回调</span>
<span class="line">                             AfterConnect);</span>
<span class="line">  }</span>
<span class="line">  args.GetReturnValue().Set(err);</span>
<span class="line">}</span>
<span class="line"></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>接着进入了 Libuv 层。</p><div class="language-c line-numbers-mode" data-highlighter="prismjs" data-ext="c" data-title="c"><pre><code><span class="line"><span class="token keyword">int</span> <span class="token function">uv__tcp_connect</span><span class="token punctuation">(</span><span class="token class-name">uv_connect_t</span><span class="token operator">*</span> req<span class="token punctuation">,</span></span>
<span class="line">                    <span class="token class-name">uv_tcp_t</span><span class="token operator">*</span> handle<span class="token punctuation">,</span></span>
<span class="line">                    <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span> addr<span class="token punctuation">,</span></span>
<span class="line">                    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> addrlen<span class="token punctuation">,</span></span>
<span class="line">                    uv_connect_cb cb<span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token keyword">int</span> err<span class="token punctuation">;</span></span>
<span class="line">  <span class="token keyword">int</span> r<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token comment">// 申请一个 socket 并保存 fd 到 handle 中</span></span>
<span class="line">  err <span class="token operator">=</span> <span class="token function">maybe_new_socket</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span></span>
<span class="line">                         addr<span class="token operator">-&gt;</span>sa_family<span class="token punctuation">,</span></span>
<span class="line">                         UV_HANDLE_READABLE <span class="token operator">|</span> UV_HANDLE_WRITABLE<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 以非阻塞的方式发起一个 TCP 连接</span></span>
<span class="line">  <span class="token function">connect</span><span class="token punctuation">(</span><span class="token function">uv__stream_fd</span><span class="token punctuation">(</span>handle<span class="token punctuation">)</span><span class="token punctuation">,</span> addr<span class="token punctuation">,</span> addrlen<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"> </span>
<span class="line">  <span class="token comment">// 初始化一个 request，并设置某些字段</span></span>
<span class="line">  <span class="token function">uv__req_init</span><span class="token punctuation">(</span>handle<span class="token operator">-&gt;</span>loop<span class="token punctuation">,</span> req<span class="token punctuation">,</span> UV_CONNECT<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  req<span class="token operator">-&gt;</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 保存关联的 handle</span></span>
<span class="line">  req<span class="token operator">-&gt;</span>handle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">uv_stream_t</span><span class="token operator">*</span><span class="token punctuation">)</span> handle<span class="token punctuation">;</span></span>
<span class="line">  <span class="token function">QUEUE_INIT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>req<span class="token operator">-&gt;</span>queue<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  handle<span class="token operator">-&gt;</span>connect_req <span class="token operator">=</span> req<span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 注册到 IO 观察者队列，handle-&gt;io_watcher 已经保存了 fd</span></span>
<span class="line">  <span class="token function">uv__io_start</span><span class="token punctuation">(</span>handle<span class="token operator">-&gt;</span>loop<span class="token punctuation">,</span> <span class="token operator">&amp;</span>handle<span class="token operator">-&gt;</span>io_watcher<span class="token punctuation">,</span> POLLOUT<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>uv__tcp_connect 以非阻塞的方式发起 TCP 连接，这样就不会阻塞线程，接着把相关请求信息保存到请求对象中，最后注册可写事件，等待连接结果。执行完的结构图如下（ConnectWrap 继承 ReqWrap，TCPWrap 继承 HandleWrap）。</p><p>tu 11-10</p><p>连接结束后就会执行 uv__stream_connect，该函数在流机制的课程中已经讲过，就不再具体分析，它主要是获取连接结果，然后执行 C++ 层的 AfterConnect。</p><div class="language-c++ line-numbers-mode" data-highlighter="prismjs" data-ext="c++" data-title="c++"><pre><code><span class="line">template &lt;typename WrapType, typename UVType&gt;</span>
<span class="line">void ConnectionWrap&lt;WrapType, UVType&gt;::AfterConnect(uv_connect_t* req,</span>
<span class="line">                                                    int status) {</span>
<span class="line">  // 根据引用关系拿到请求对应的 JS 层请求上下文，</span>
<span class="line">  // 具体是在发起 connect 时设置的（void ReqWrap&lt;T&gt;::Dispatched()）</span>
<span class="line">  std::unique_ptr&lt;ConnectWrap&gt; req_wrap(static_cast&lt;ConnectWrap*&gt;(req-&gt;data));</span>
<span class="line">  </span>
<span class="line">  // 根据引用关系拿到请求对应的 C++ 层 TCPWrap 对象，具体是 HandleWrap::HandleWrap 设置的</span>
<span class="line">  WrapType* wrap = static_cast&lt;WrapType*&gt;(req-&gt;handle-&gt;data);</span>
<span class="line">  Environment* env = wrap-&gt;env();</span>
<span class="line"></span>
<span class="line">  Local&lt;Value&gt; argv[5] = {</span>
<span class="line">    Integer::New(env-&gt;isolate(), status),</span>
<span class="line">    wrap-&gt;object(),</span>
<span class="line">    req_wrap-&gt;object(),</span>
<span class="line">    ...</span>
<span class="line">  };</span>
<span class="line">  // 执行 JS 层 oncomplete 回调函数</span>
<span class="line">  req_wrap-&gt;MakeCallback(env-&gt;oncomplete_string(), arraysize(argv), argv);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>AfterConnect 会执行 oncomplete 属性对应的函数，对应的是 JS 层的 afterConnect。</p><div class="language-javascript line-numbers-mode" data-highlighter="prismjs" data-ext="js" data-title="js"><pre><code><span class="line"><span class="token keyword">function</span> <span class="token function">afterConnect</span><span class="token punctuation">(</span><span class="token parameter">status<span class="token punctuation">,</span> handle<span class="token punctuation">,</span> req<span class="token punctuation">,</span> readable<span class="token punctuation">,</span> writable</span><span class="token punctuation">)</span> <span class="token punctuation">{</span></span>
<span class="line">  <span class="token comment">// 获取 C++ 层对象关联的 JS socket 对象，在创建 socket 对象时设置的</span></span>
<span class="line">  <span class="token keyword">const</span> self <span class="token operator">=</span> handle<span class="token punctuation">[</span>owner_symbol<span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 触发 connect 事件</span></span>
<span class="line">  self<span class="token punctuation">.</span><span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">&#39;connect&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">  <span class="token comment">// 如果需要开启读操作，则注册可读事件</span></span>
<span class="line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>readable <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>self<span class="token punctuation">.</span><span class="token function">isPaused</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line">    self<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样就完成了 TCP连接，一般情况下，连接成功后，JS 层会调用 self.read(0) 注册等待可读事件，我们下节课再详细讲解。</p><p>总结 TCP 协议是 TCP / IP 协议簇中非常重要且复杂的协议，这一节课我们首先介绍了 TCP 协议的概念和特性。</p><p>面向连接：通信前需要先建立连接，使用完需要关闭（主动关闭或者空闲时间达到阈值由操作系统关闭）。</p><p>可靠：发送端通过超时重发和确认等机制确保数据发送到对端。</p><p>流式协议：把数据当作 01 比特流传输，不感知所承载的数据格式，数据由上层解释。</p><p>全双工：通信两端可以同时发送和接收数据，两端都有自己的发送和接收缓冲区。</p><p>我们需要对这 TCP 协议的核心概念有深入的理解才能更好地理解 TCP 协议的工作原理。这样我们学习和使用 RPC 或者 HTTP 等协议时也会更容易。</p><p>接着我们讲了在网络编程中如何通过 TCP 协议进行通信。TCP 通信涉及服务器和客户端两个端。</p><p>服务器首先申请一个 socket，然后调用 bind 绑定地址，接着通过 listen 进入监听状态，有连接到来时通过 accept 进行处理。</p><p>客户端相比来说简单点，客户端也是需要先申请一个 socket，然后通过 connect 发起对服务器的连接就行，我们也可以选择通过 bind 绑定本地地址到 socket 中，但是通常不需要。</p><p>讲完基础部分后，最后我们深入分析了 Node.js 中 TCP 服务器和客户端的实现。它本质上是结合网络编程和 V8 实现的。</p><p>服务器的实现：Node.js 中，通过 createServer() 可以创建一个服务器，接着调用它的 listen 函数就可以启动服务器，listen 函数本质上是对操作系统 bind 和 listen 的封装，执行完 listen 后，Node.js 注册了可读事件等待连接的到来，当新连接到来时，操作系统会通知 Node.js，从而 Node.js 处理该连接。</p><p>客户端的实现：Node.js 中，通过 net.connect 可以发起一个 TCP 连接，connect 本质上是对操作系统 bind 和 connect 的封装，调用 connect 函数后，Node.js 注册了等待可写事件，接着操作系统会发起三次握手，等待连接结束后，操作系统会通知 Node.js，Node.js 通过系统 API 获取连接结果。</p><p>深入理解 Node.js 中 TCP 服务器和客户端的实现，不仅可以帮助我们更好地使用 Node.js，同时碰到问题时我们也可以自己排查。</p><p>下一节课我们会在服务器和客户端建立的 TCP 连接的基础上讲解数据通信、连接管理以及 TCP 常用的一些特性。</p>`,120)]))}const o=s(t,[["render",l],["__file","tcp_server_client.html.vue"]]),u=JSON.parse('{"path":"/nodejs/deep_into_nodejs/tcp_server_client.html","title":"tcp基础和客户端/服务器的实现","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"TCP 协议是什么？","slug":"tcp-协议是什么","link":"#tcp-协议是什么","children":[]},{"level":2,"title":"面向连接的本质","slug":"面向连接的本质","link":"#面向连接的本质","children":[{"level":3,"title":"可靠","slug":"可靠","link":"#可靠","children":[]},{"level":3,"title":"流式协议的本质","slug":"流式协议的本质","link":"#流式协议的本质","children":[]},{"level":3,"title":"全双工的本质","slug":"全双工的本质","link":"#全双工的本质","children":[]},{"level":3,"title":"TCP 协议的使用","slug":"tcp-协议的使用","link":"#tcp-协议的使用","children":[]},{"level":3,"title":"处理连接","slug":"处理连接","link":"#处理连接","children":[]}]},{"level":2,"title":"Node.js TCP 客户端的实现","slug":"node-js-tcp-客户端的实现","link":"#node-js-tcp-客户端的实现","children":[]}],"git":{"updatedTime":1705375577000,"contributors":[{"name":"sindorei","email":"wupan1030@foxmail.com","commits":1,"url":"https://github.com/sindorei"}]},"filePathRelative":"nodejs/deep_into_nodejs/tcp_server_client.md"}');export{o as comp,u as data};
