import{_ as i,c as l,f as a,o as t}from"./app-LHpjaFTr.js";const r={};function s(o,e){return t(),l("div",null,e[0]||(e[0]=[a('<h1 id="更新缓存的最佳方式" tabindex="-1"><a class="header-anchor" href="#更新缓存的最佳方式"><span>更新缓存的最佳方式</span></a></h1><ul><li><p>Redis 是一个使用内存保存数据的高性能 KV 数据库，它的高性能主要来自于：</p><ul><li>简单的数据结构</li><li>使用内存存储数据</li></ul></li><li><p>缓存更新策略</p><ul><li><p>Read/Write Through</p><ul><li>在并发的情况下，有一定的概率会出现“脏数据”问题，缓存中的数据可能会被错误地更新成了旧数据</li></ul></li><li><p>Cache Aside</p><ul><li>更新数据的时候，并不去尝试更新缓存，而是去删除缓存。</li><li>避免并发读写导致的脏数据问题</li></ul></li></ul></li></ul><h1 id="注意缓存穿透引起雪崩" tabindex="-1"><a class="header-anchor" href="#注意缓存穿透引起雪崩"><span>注意缓存穿透引起雪崩</span></a></h1><ul><li>当系统初始化的时候，比如说系统升级重启或者是缓存刚上线，这个时候缓存是空的，如果大量的请求直接打过来，很容易引发大量缓存穿透导致雪崩。为了避免这种情况，可以采用灰度发布的方式，先接入少量请求，再逐步增加系统的请求数量，直到全部请求都切换完成。</li><li>或在系统启动的时候对缓存进行预热。所谓的缓存预热就是在系统初始化阶段，接收外部请求之前，先把最经常访问的数据填充到缓存里面，这样大量请求打过来的时候，就不会出现大量的缓存穿透了</li><li>如果说构建缓存数据需要的查询时间太长，或者并发量特别大的时候，Cache Aside 或者是 Read/Write Through 这两种缓存模式都可能出现大量缓存穿透。对于这种情况，并没有一种方法能应对所有的场景，你需要针对业务场景来选择合适解决方案。比如说，可以牺牲缓存的时效性和利用率，缓存所有的数据，放弃 Read Through 策略所有的请求，只读缓存不读数据库，用后台线程来定时更新缓存数据。</li></ul>',4)]))}const c=i(r,[["render",s],["__file","11.html.vue"]]),h=JSON.parse('{"path":"/geektime/back-end-storage-practical-lession/11.html","title":"更新缓存的最佳方式","lang":"zh-CN","frontmatter":{},"headers":[],"git":{"updatedTime":1644980618000,"contributors":[{"name":"sindorei","email":"wupan1030@foxmail.com","commits":1,"url":"https://github.com/sindorei"}]},"filePathRelative":"geektime/back-end-storage-practical-lession/11.md"}');export{c as comp,h as data};
