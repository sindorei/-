f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   1) 标准的System名称空间包含了最常用的.NET类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   2) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   3) 在C#中做的所有工作都依赖于.NET基类
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   4) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   5) 几乎所有的C#程序都使用System命名空间中的类
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   6) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   7) # 变量
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   8) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800   9) 用 var 声明变量：
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  10) - 变量必须初始化
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  11) - 初始化器不能为空
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  12) - 初始化器必须放在表达式中
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  13) - 不能把初始化器设置为一个对象，除非在初始化器中创建了一个对象
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  14) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  15) ### 变量的作用域
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  16) - 局部变量存在于表明该变量的块语句或方法结束的右花括号之前的作用域内
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  17) - 在for、while或类似语句中声明的局部变量存在于该循环体内
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  18) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  19) ### 常量
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  20) ```C#
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  21) const int a = 100;
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  22) ```
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  23) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  24) - 常量必须在声明时初始化。指定了值后，就不能再更改。
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  25) - 常量的值必须能在编译时用于计算。因此，不能用从一个变量中提取的值来初始化常量。如果需要这么做，应使用只读字段。
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  26) - 常量总是静态的。但注意，不必在常量声明中包含修饰符static
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  27) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  28) 程序中使用常量的好处：
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  29) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  30) - 由于使用易于读取的名称替代了较难读取的数字或字符串，常量使程序变得更易于阅读
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  31) - 常量使程序更易于修改
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  32) - 常量更容易避免程序出现错误
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  33) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  34) # 数据类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  35) - 值类型 存储在堆栈中
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  36) - 引用类型 存储在托管堆上
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  37) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  38) 如果变量是一个引用类型，可以把其值设为null，表示不引用任何对象
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  39) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  40) 如果将引用设置为null，就不可能对它调用任何非静态的成员函数或字段，这么做会在运行期间抛出一个异常
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  41) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  42) # CTS类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  43) c#认可的基本预定义类型并没有内置于C#语言中，而是内置于.NET Framework中
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  44) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  45) 在语法上，可以把所以的基本数据类型看作是支持某些方法的类
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  46) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  47) C#中声明一个int类型的数据，实际上是.NET结构System.Int32的一个实例
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  48) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  49) C#有15个预定义类型，其中13个是值类型，2个是引用类型（string和Object）
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  50) # 预定义的值类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  51) ### 整型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  52) - sbyte  System.SByte 8位有符号的整数
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  53) - short System.Int16 16位有符号的整数
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  54) - int 32位
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  55) - long 64位
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  56) - byte 8位无符号整数
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  57) - unshort System.UInt16 16位无符号整数
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  58) - uint
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  59) - ulong
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  60) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  61) 如果对一个整数是int、uint、long或者是ulong没有任何显示的声明，则该变量默认为int类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  62) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  63) 为了把输入的值指定为其他整数类型，需在数字后加字符，不区分大小写。推荐大写
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  64) ```C#
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  65) uint ui = 123U;
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  66) long l = 1234L;
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  67) ulong ul = 1234UL;
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  68) ```
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  69) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  70) ### 浮点类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  71) - float System.Single 32位单精度浮点数  位数7
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  72) - double System.Double 64位双精度浮点数 位数15/16
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  73) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  74) 如果代码中没有对某个非整数值硬编码，则编译器一般假定该变量是double。如果要指定为float，需在值后加上F（或f）：
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  75) ```C#
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  76) float f = 12.3F;
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  77) ```
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  78) ### decimal类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  79) decimal System.Decimal 128位高精度十进制表示法  位数 28 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  80) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  81) 要把数字指定为decimal类型，而不是double、float或整型，可在数字后面加上M
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  82) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  83) decimal类型不是基本类型，在计算时使用此类型会有性能损失
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  84) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  85) ### bool类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  86) bool System.Boolean true、false
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  87) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  88) bool值和整数值不能相互隐式转换
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  89) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  90) ### 字符类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  91) char System.Char 表示一个16位的Unicode字符
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  92) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  93) char类型的字面量是用单引号括起来的，如`'a'`。如果把字符放在双引号中，编译器会把它看做字符串，从而产生错误。
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  94) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  95) 还可以用4位十六进制的Unicode值如：`'\u0041'`，带有数据类型转换的整数值`(char)65`或十六进制数`'\x0041'`， 转义序列表示它们
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  96) 
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  97) # 预定义的引用类型
f9ce9b75 (sindorei 2015-10-11 17:43:07 +0800  98) - object System.Object 根类型，CTS中的其他类型都是从它派生出来的，包括值类型
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800  99) - string System.String Unicode字符串
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 100) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 101) 字符串是不可改变的
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 102) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 103) # 流控制
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 104) ### 条件语句
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 105) - if
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 106) - switch
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 107) ### 循环
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 108) - for循环
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 109) - while循环
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 110) - do while循环
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 111) - foreach循环
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 112) ### 跳转语句
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 113) - goto 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 114) ```C#
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 115) goto label;
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 116) label:
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 117)      int i = 0;
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 118) ```
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 119) - break
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 120) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 121) switch，while、do while、for循环中使用
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 122) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 123) - continue
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 124) - return
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 125) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 126) # 枚举
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 127) 枚举是用户定义的整数类型。在声明一个枚举时，要指定该枚举的实例可以包含的一组可接受的值。
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 128) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 129) 使用枚举比使用无格式的整数至少有如下3个优势：
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 130) - 枚举可以使代码更易于维护，有助于确保给变量指定合法的、期望的值
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 131) - 枚举使代码更清晰，允许用描述性的名称表示整数值。而不是用含义模糊、变化多端的数来表示。
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 132) - 枚举也使代码更易于键入。
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 133) ```C#
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 134) public enum TimeOfDay
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 135) {
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 136)     Morning = 0,
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 137)     Afternoon = 1,
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 138)     Evening = 2
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 139) }
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 140) ```
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 141) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 142) 枚举的真正强大之处是它们在后台会实例化为派生与基类System.Enum的结构。一旦编译好，枚举就成为基本类型，与int和float类似。
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 143) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 144) 从字符串中获取枚举值 `Enum.Parse()`
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 145) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 146) # 名称空间
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 147) 可以给名称空间指定一个别名
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 148) ```c#
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 149) using alias = NamespaceName;
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 150) ```
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 151) 
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 152)  别名修饰符 `::`，`Introduction::NamespaceExample NSEX = new Introduction::NamespaceExample`
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 153)  
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 154)  # Main()方法
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 155)  
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 156)  多个Main()方法会报错，可以用`/main`选项，其后跟Main()方法所属类的全名（包括名称空间），明确告诉编译器把哪个方法作为程序的入口点：
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 157)  ```C#
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 158)  csc DoubleMain.cs /main:Wrox.MathExample
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 159)  ```
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 160)  
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 161)  Main()方法可以传递参数，此参数为字符串数组
2bdeec85 (sindorei 2015-10-11 18:57:18 +0800 162)  
0f13639f (sindorei 2015-10-11 22:38:18 +0800 163)  在启动程序时，程序可以使用这个数组，访问通过命令行传送过来的选项
0f13639f (sindorei 2015-10-11 22:38:18 +0800 164)  
0f13639f (sindorei 2015-10-11 22:38:18 +0800 165)  # 控制台 I/O
0f13639f (sindorei 2015-10-11 22:38:18 +0800 166)  
0f13639f (sindorei 2015-10-11 22:38:18 +0800 167)  - Console.ReadLine() 从控制台窗口读取一行文本
0f13639f (sindorei 2015-10-11 22:38:18 +0800 168)  - Console.Write()  将制定的值写入控制台窗口
0f13639f (sindorei 2015-10-11 22:38:18 +0800 169)  - Console.WriteLine() 和Console.Write() 类似，但在输出结果最后添加一个换行
0f13639f (sindorei 2015-10-11 22:38:18 +0800 170)  
0f13639f (sindorei 2015-10-11 22:38:18 +0800 171)  # C#预处理器指令
0f13639f (sindorei 2015-10-11 22:38:18 +0800 172)  
