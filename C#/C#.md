# C#编译执行过程
- C#源代码通过C#编译器(csc.exe)编译成.exe的.net程序集（MSIL代码）
- 编译好的.exe文件并不是真正的操作系统可以理解的二进制指令
- 双击.exe文件执行时，再次进行编译（JIT），生成真正的cpu指令代码

# 字符串常用方法
- 属性
    * length  获取字符串中字符的个数
- 方法
    * IsNullOrEmpty() 今天方法判断是null或者为""
        - 内部实现是判断为null 或者 length为0
    * ToCharArray() 将string转换为char[]
    * ToLower() 转成小写，返回新的字符串
    * ToUpper() 转成大写，返回新的字符串
    * Equals()
        - 比较2个字符串是否相同
    * IndexOf()
        - 第一次出现的位置
        - 没找到返回-1
    * LastIndexOf()
        - 最后一次出现的位置
        - 没找到返回-1
    * SubString()
        - 截取字符串
        - 参数1：开始截取的索引
        - 参数2： 截取的长度，可以选，不传则截到最后
    * Split()
        - 第一参数，可选择去掉空实体
    * Join() 静态方法
    * Format()  静态方法
    * Replace()

# 值类型与引用类型

值类型存储在栈上（值类型的大小固定）

引用类型存储在堆上

值类型均隐式派生自System.ValueType

引用类型派生自System.Object

引用类型变量的复制，只复制对对象的引用

值类型变量赋值会拷贝一个副本

##  参数引用传递
- 用`ref`关键字修饰，方法调用的时候参数也要加`ref`。传参前需要初始化
- `out` 传递前可以不初始化。


# 面向对象
- 类中成员的默认访问修饰符是private
- 局部变量要求使用前，必须先声明并且赋值
- 类的成员变量有默认值（值类型为0，引用类型为null），可以不赋默认值
- 一个类默认有个无参数的构造函数，手动增加一个构造函数后会将原有的无参数的构造函数覆盖

## 访问修饰符
- 作用：指明程序的其他部分如何访问该成员
- private
  * 只有在当前类中才能访问
- protected
  * 当前类和子类中可以访问
- internal
  * 当前程序集中可以访问
  * 类的访问修饰符默认就是internal
- protected internal
  * 当前类内部，所以子类内部，当前程序集内部
- public
  * 任何地方

所有在命名空间中直接定义的类型（类、委托、枚举、结构），访问修饰符只能是public或private

方法的返回值的类型的访问修饰符必须与方法的访问修饰符兼容

方法的参数的访问修饰符必须与方法的访问修饰符兼容

子类的访问修饰符必须与父类的访问修饰符兼容（不能比父类的高）

## 封装
## 继承
- 代码重用
- 多态
- 父类比子类更抽象

特性：

- 单根性
  * 一个类只能继承一个父类
- 传递性

继承中的构造函数问题

- 子类在实例化时，子类的构造函数默认情况下都会调用父类的无参数的构造函数，如果父类中没有无参数的构造函数就会出错。
- 子类构造函数 用 `:base()`指定调用父类的构造函数。
- 执行顺序：先调父类的构造函数，再调用子类的构造函数
- `:this()` 可以指定调用本类中的其他构造函数

里氏替换原则：

- 声明父类类型变量，指向子类类型对象
## 多态

作用：

把布同的子类对象都当作父类来看，可以屏蔽不同子类对象之间的差异，写出通用的嗲吗，做出通用的编程，以适应需求的不断变化。

is

- obj is 某类型 判断是否是某个类型

as

- 类型转换，转换失败返回null，不会报异常



多态的实现：

- 虚方法（子类重写父类中的方法）
  *  父类中需要设置为虚方法的方法标记 virtual `public virtual void CheckIn`
  * 子类 重写 方法标记 override `public override void CheckIn`
  * 虚方法在父类中必须有实现
  * 子类继承父类后，可以选择对虚方法进行重写也可以选择不重写
  * 子类重写父类中的方法时，必须保证重写后的方法与原方法的访问修饰符、方法名、参数完全一致
  * 当方法的标记是virtual或override时，都可以重写
- 抽象类（子类重写父类中的方法）
  * 使用 abstract 关键字标记方法
  * 抽象方法在父类中不能有任何实现，所以抽象方法没有方法体。
  * 抽象成员必须写在抽象类中
  * 抽象类是不能被实例化的，不能直接new一个抽象类的对象
  * 抽象类中既可以有抽象成员，也可以有实例成员
  * 抽象成员不能是私有的
  * 子类继承抽象类后，对于抽象类中的抽象成员子类必须重写（除非子类也标记abstract）
  *

- 接口（实现接口的类，将接口中的方法实现）
    * 接口就是一种规范，约定好遵守某种规范就可以写通用的代码
    * 定义了一组具有各种功能的方法
    * 意义：多态。多态的意义：程序的可扩展性
    * interface 关键字
    * 一般接口以大写I开头
    * 接口中只能包含方法（属性、时间、所引起最终都是方法）
    * 接口中的成员不能有任何访问修饰符，默认是public
    * 接口中的成员不能有实现，接口不能实例化
    * 定义一个类来实现该接口
    * 实现接口的类，必须将接口中的所有成员都实现，除非是抽象类
    * 实现接口的类直接实现接口中的方法即可，无需使用override关键字
    * 当多个类型不能抽象出合理的父类时，但是又要对某些方法进行多态，此时可以用接口来实现多态。即把公共的方法抽象到一个接口中，让不同的子类实现该接口
    * 因为接口可以多实现，所以解决了类的单继承问题

 使用接口的建议：

 - 面向抽象编程，使用更抽象（父类、抽象类、接口）不使用具体
 - 向上转型
 - 编程时:
    * 接口-> 抽象类 -> 父类 -> 具体类（在定义方法参数、返回值、声明变量的时候，能用抽象就不要用具体。）
    * 能用接口就不要用抽象类，能用抽象类就不要用父类，能用父类就不要用子类
    * 避免定义体积庞大的接口、多功能接口。
    * 定义多个职责单一的接口（组合使用）




## 静态
- 静态成员不能通过对象访问，只能通过类名直接访问
- 静态内容在内存中只存储一份，而实例成员每创建一个对象，就存储一份内容
- 所有对象共享的信息可以再实例类中加一个静态成员来表示
- 静态成员，在这个应用程序中任何一个地方都可以访问的到，直到程序退出后才会释放内存。
- 静态类中，只能有静态成员，不能有实例成员
- 静态类不能创建对象，不能new
- 可以把一些常用的工具函数封装到一个静态类中，使用方便

静态构造函数

- 必须使用static关键字修饰
- 没有访问修饰符
- 静态构造函数不能有参数，也不能重载
- 在第一次使用该静态类之前，调用一次构造函数（只会被调用一次）

# 类型转换
## 类型转换 cast
- 只有在内存存储上存在交集的类型之间才能进行隐式转换
- 不能用Cast转换 string/int ，只能用Convert
## 类型转换 convert
- 任意类型转换成字符串
  * ToString()
- 将字符串转成数值类型
  * `int.Parse(string str)`
  * `int.TryParse(string str , out int n)`
  * Parse() 转换失败报异常，TryParse()转换失败不报异常
- as 与直接类型转换
  * `if(p is Student) { Student stu = (Student)p; }`
    - CLR 会进行两次类型检查
    - 通过`GetType()`,GetType()不允许重写。
  * `Student stu p as Student` 推荐，效率高于第一中。转换失败返回null，不会报异常。

 # 异常处理
 - try  `catch()` 可以有多个 `finally`(最多只能有一个)
 - 有finally时可以没有catch
 - 注意点：
    * 发生异常后，try块中，异常代码后的代码不会执行
    * finally块中的代码，无论是否发生异常都会执行
    * finally中不能写return语句
    * try中有return语句，finally也会执行（在return之前执行），编译后的IL代码将return 移到了最后
    * 异常时即便没有catch(或者没有找到合适的catch块)，finally中的代码也会执行，但finally之后的代码不会执行
  - Exception 类主要属性 ： Message、StackTrace、InnerException
  - 自己抛出异常，throw
  - 建议：
    * 通过逻辑判断减少异常发生的可能性。尽量避免使用异常处理
    * 在多级方法嵌套调用的时候，如果发生了异常，则会终止所有相关方法的调用，并且释放相关资源

    # 参数修饰符
    - params
      * 可变参数
      * 可以传递多个参数，也可以直接传数组
      * 不传参数时，可变参数是一个长度为0的数组
      * 如果该方法有多个参数，可变参数必须写在最后
    - ref
      * 传递的引用地址
      * 需初始化（参数传递前先赋值）
      * 方法内可以不赋值，可以直接使用。
    - out
      * 传参前可以不初始化，即使初始化赋值了也没有意义，out参数不能将方法外的值带入方法内。
      * 方法内必须赋值

     - ref应用在内部对外部的值进行改变，out则是内部为外部变量赋值，out一般用在函数有多个返回值的场所


# Equals、==、Object.ReferenceEquals比较相等
- Equals
    * 默认情况下可以调用对象的Equals方法来验证两个对象是否是同一个对象，但是改方法时可以被重写的，所以子类有可能把该方法重写，当子类把该方法重写后，则通过该方法验证两个对象是否是同一个对象就不准确了，所以不要依赖Equals方法或==来判断两个对象是否是同一个对象。
    * 字符中Equals和==都是判断字符串的内容是否相等不是判断字符串的地址
    * == 的内部就是调用的Equals方法来进行判断的
 - Object.ReferenceEquals()
    * 判断对象是否相等

# 字符串的特性
- 直接定义的字符串常量不会被垃圾回收
- 字符串暂存池
    * 内部维护一个哈希表，key为字符串，value是地址。每次为一个新变量赋值都会找key中是否有，如有有则直接把value中的地址赋值给新变量。这个特性依赖于字符串的另外一个特性才能存在：字符串的不可变性。
- 字符串的不可变性
    * 一旦创建不可改变。
    * 由于字符串的不可变性，所以多个字符串进行拼接时，会导致内存和时间的消耗。

# StringBuilder
- 每次修改都是修改同一块内存中的值，不会重复创建大量对象，也不会产生垃圾内存。大大提高了字符串拼接的效率。

# 垃圾回收
- 目的：提高内存利用率
- 只回收托管堆中的内存资源，不回收其他资源（数据库连接，文件句柄，网络端口等）
- 值类型变量是不需要垃圾回收的，执行完毕后就立即出栈释放了。垃圾回收只回收堆中的内存资源。
- 什么样的对象才会被回收？
    * 没有变量引用的对象。（可以被回收了）
- 什么时间回收
  * 不确定，当程序需要新内存的时候开始执行回收
  * GC.Collect() 手动调用垃圾回收。不建议使用，垃圾回收时会暂停一下（非常短暂）
- 垃圾回收中“代”的概念
  * 共3代：第0代、第1代、第2代
  * 各代的回收频率
    - 第0代最高，其次第1代，再次第2代。越老的对象生存几率越大
  * 当第0代内存不够用时会回收第0代。没被回收的升级为第1代。当第0代不够用，且没有被回收的，会回收第1代。
- .net中垃圾回收机制：mark-and-compact（标记和压缩）
    * 一开始假设所有对象都是垃圾
- 除了内存资源外的其他资源怎么办？
 * Dispose()

# 集合
- 集合命名空间
    * System.Collections 非泛型集合
    * System.Collections.Generic 泛型集合
- 常用集合
    * 类似数组集合： ArraryList、List<T>
    * 键值对集合：Hashtable、Dictionary<k,v>
    * 堆栈集合: Stack、Stack<T>(LIFO)
    * 队列集合： Queue、Queue<T>(FIFO)
    * 可排序键值对集合：插入、检索没有哈希表集合高效
        * SortedList、SortedList<K,V> 占用内存更少，可通过索引访问
        * SortedDictionary<K,V> 占用内存更多，没有索引，但插入、删除元素的速度比SortedList快
    * Set集合：无序、不重复。HashSet<T> 可以将HashSet类似为不包含值的Dictionary集合。与List<T>类似。SortedSet<T>(.net4.0支持，有序无重复集合)
    * 双向链表集合：LinkedList<T> 增删速度快

 - ArrayList
    * Count 实际元素个数
    * Capacity 表示容量  ， 不够时会翻倍
        * Count 为0 Capacity为0 ， Count为1 Capacity 为4
    * Add()
    * AddRange()
    * Insert()
    * Clear() 长度不变，每个元素变成默认值，值类型为0，引用类型为null
    * Remove()
    * RemoveAt()
    * Contains()
    * ToArray()
        * 返回Object数组
    * Sort()
      * 字符串 是按照 字母顺序
      * 调用CompareTo()方法排序 ， 此方法时IComparable接口中定义的
      * 可实现IComparable 接口来定义改类型对象的比较规则
      * 可自定义比较器定义比较规则比较器类（实现IComparer接口） 可定义不同的比较器来实现不同的比较
 - HashTable
    * Add(键,值)
    * Remove(键)
    * 遍历
        - foreach
            * DictionaryEntry
  - List
  - Dictionary

# 装箱与拆箱
- 将值类型转换为引用类型叫装箱
- 将引用类型转换为值类型叫拆箱
- 装箱用什么数据类型装，拆箱就要用什么类型拆

# 文件操作
- File
    * 操作文件，静态类，对文件整体操作。拷贝、删除、剪切等。
- Directory
    * 操作目录（文件夹），静态类
- DirectoryInfo
    *  文件夹类 用来描述一个文件夹对象
- FileInfo
    * 文件类，用来描述一个文件对象。获取指定目录下的所有文件时，返回一个FileInfo数组
- Path
    * 对文件或目录的路径进行操作
- Stream 文件流，抽象类
    *
