# vue ssr
- 客户端和服务端分开构建
- 开发和生产区分
- 调用服务端渲染函数`renderToString`、`renderToStream`等返回渲染结果

## vue2

### 服务端构建入口entry-server.js
```javascript
import { createApp } from './app' // 服务端和客户端共用的
export default context => {
    return new Promise((resolve, reject) => {
        const { app, router, store } = createApp()
        const { url, channel } = context
        // set router's location
        router.push(url)
        router.onReady(() => {
            const matchedComponents = router.getMatchedComponents()
            if (!matchedComponents.length) {
                reject({ code: 404 })
            }
            // Call preFetch hooks on components matched by the route.
            // A preFetch hook dispatches a store action and returns a Promise,
            // which is resolved when the action is complete and store state has been
            // updated.
            store.dispatch('SET_CHANNEL', { channel: channel })

            Promise.all(matchedComponents.map(({ asyncData }) => asyncData && asyncData({
                store,
                route: router.currentRoute
            }))).then(() => {
                context.state = store.state
                context.initialState = store.state
                resolve(app)
            }).catch(reject)
        }, reject)
    })
}
```

### 服务端入口apps.js
```javascript
const serialize = require('serialize-javascript')
// /src/platforms/web/entry-server-renderer.js
const { createBundleRenderer } = require('vue-server-renderer')
const template = fs.readFileSync(resolve('./src/index.template.html'), 'utf-8')
function createRenderer(bundle, options) {
    // 内部调用/src/server/create-renderer.js 
    // 模板会处理 vue/src/server/template-renderer/index.js
    return createBundleRenderer(
        bundle,
        Object.assign(options, {
            template,
            cache: new LRU({
                max: 1000,
                maxAge: 1000 * 60 * 15
            }),
            basedir: resolve('./dist'),
            runInNewContext: false
        })
    )
}

const bundle = require('./dist/vue-ssr-server-bundle.json')
const clientManifest = require('./dist/vue-ssr-client-manifest.json')
renderer = createRenderer(bundle, {
    clientManifest
})
app.get('/*', (req, res) => {
    let buffers = []
    const context = {
            title: '',
            url: req.url.replace(baseUrl, '/'),
            channel: '',
    }
    const stream = renderer.renderToStream(context)
    stream.on('data', data => {
        buffers.push(data)
    })
    stream.on('end', () => {
        if (context.initialState) {
            res.write(
                `<script>window.__INITIAL_STATE__=${serialize(
                    context.initialState,
                    {
                        isJSON: true
                    }
                )}</script>`
            )
        }
        let html = Buffer.concat(buffers).toString()
        res.end(html)
    })
    stream.on('error', err => {
        // do some error handling
    })
})
```

### index.template.html
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>{{ title }}</title>
</head>
<body>
    <!--vue-ssr-outlet-->
</body>
</html>
```

## vue3

### 服务端构建入口entry-server.ts
```typescript
import { createApp } from './main' // 客户端和服务端共用，需调用createSSRApp
import { renderToString } from '@vue/server-renderer'

export async function render(url: string, manifest: any) {
    const { app, router } = createApp()

    // set the router to the desired URL before rendering
    router.push(url)
    await router.isReady()

    // passing SSR context object which will be available via useSSRContext()
    // @vitejs/plugin-vue injects code into a component's setup() that registers
    // itself on ctx.modules. After the render, ctx.modules would contain all the
    // components that have been instantiated during this render call.
    const ctx: any = {}
    const html = await renderToString(app, ctx)

    // the SSR manifest generated by Vite contains module -> chunk/asset mapping
    // which we can then use to determine what files need to be preloaded for this
    // request.
    const preloadLinks = renderPreloadLinks(ctx.modules, manifest)
    return [html, preloadLinks]
}

function renderPreloadLinks(modules: any, manifest: any) {
    let links = ''
    const seen = new Set()
    modules.forEach((id: any) => {
        const files = manifest[id]
        if (files) {
            files.forEach((file: any) => {
                if (!seen.has(file)) {
                    seen.add(file)
                    links += renderPreloadLink(file)
                }
            })
        }
    })
    return links
}

function renderPreloadLink(file: any) {
    if (file.endsWith('.js')) {
        return `<link rel="modulepreload" crossorigin href="${file}">`
    } else if (file.endsWith('.css')) {
        return `<link rel="stylesheet" href="${file}">`
    } else if (file.endsWith('.woff')) {
        return ` <link rel="preload" href="${file}" as="font" type="font/woff" crossorigin>`
    } else if (file.endsWith('.woff2')) {
        return ` <link rel="preload" href="${file}" as="font" type="font/woff2" crossorigin>`
    } else if (file.endsWith('.gif')) {
        return ` <link rel="preload" href="${file}" as="image" type="image/gif" crossorigin>`
    } else if (file.endsWith('.jpg')) {
        return ` <link rel="preload" href="${file}" as="image" type="image/jpeg" crossorigin>`
    } else if (file.endsWith('.jpeg')) {
        return ` <link rel="preload" href="${file}" as="image" type="image/jpeg" crossorigin>`
    } else if (file.endsWith('.png')) {
        return ` <link rel="preload" href="${file}" as="image" type="image/png" crossorigin>`
    } else {
        return ''
    }
}

```

### 服务端入口文件apps.js
```typescript
let template = await fs.promises.readFile('src/index.html', 'utf-8').catch(err => {
    console.log(err)
})

const render = require(`../dist/server/entry-server.js`)?.render
const manifest = require('../dist/client/ssr-manifest.json')

app.use('*', async (req, res, next) => {
  
    const url = req.originalUrl
    const [appHtml, preloadLinks] = await render(
        url,
        manifest
    )
    const html = template
        .replace(`<!--preload-links-->`, preloadLinks)
        .replace(`<!--app-html-->`, appHtml)
    res.status(200).set({
        'Content-Type': 'text/html'
    }).end(html)
    })
```


### index.html
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <title>xxx</title>
    <!--preload-links-->
</head>
<body>
    <div id="app"><!--app-html--></div>
    <script type="module" src="/src/entry-client.ts"></script>
</body>
</html>

```