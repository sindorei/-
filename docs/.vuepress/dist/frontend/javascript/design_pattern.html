<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.33">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <title>设计模式 | 笔记</title><meta name="description" content="平时学习及练习是时的记录">
    <link rel="modulepreload" href="/assets/app.db66e77f.js"><link rel="modulepreload" href="/assets/design_pattern.html.a109d964.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper.21dcd24c.js"><link rel="modulepreload" href="/assets/design_pattern.html.2f6e44d2.js">
    <link rel="stylesheet" href="/assets/style.fc8b2427.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="https://vuejs.org/images/logo.png" alt="笔记"><span class="site-name can-hide">笔记</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><!----><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><!----><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p class="sidebar-item sidebar-heading">设计模式 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a aria-current="page" href="/frontend/javascript/design_pattern.html#aop装饰函数" class="router-link-active router-link-exact-active sidebar-item" aria-label="AOP装饰函数"><!--[--><!--]--> AOP装饰函数 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend/javascript/design_pattern.html#单一职责原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="单一职责原则"><!--[--><!--]--> 单一职责原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend/javascript/design_pattern.html#最少知识原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="最少知识原则"><!--[--><!--]--> 最少知识原则 <!--[--><!--]--></a><!----></li><li><a aria-current="page" href="/frontend/javascript/design_pattern.html#开放封闭原则" class="router-link-active router-link-exact-active sidebar-item" aria-label="开放封闭原则"><!--[--><!--]--> 开放封闭原则 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式" aria-hidden="true">#</a> 设计模式</h1><p>面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案</p><p>在某中场合下对某个问题的一种解决方案</p><p>给面向对象软件开发总的一些好的设计取个名字</p><h1 id="单例模式" tabindex="-1"><a class="header-anchor" href="#单例模式" aria-hidden="true">#</a> 单例模式</h1><ul><li>透明的单例模式</li><li>用代理实现单例</li><li>惰性单例</li></ul><h1 id="策略模式" tabindex="-1"><a class="header-anchor" href="#策略模式" aria-hidden="true">#</a> 策略模式</h1><p>策略模式定义了算法家族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化不会影响到使用算法的客户</p><ul><li>作用： <ul><li>所有的这些算法都是做相同的事情，只是实现不同</li><li>以相同的方式调用所有的方法，减少各种算法与使用算法类之间的耦合</li><li>单独定义算法类，也方便了单元测试</li></ul></li></ul><h1 id="组合模式" tabindex="-1"><a class="header-anchor" href="#组合模式" aria-hidden="true">#</a> 组合模式</h1><p>将对象组合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性</p><p>注意事项：</p><p>改模式经常和装饰者一起使用，它们通常有一个公共的父类（也就是原型），因此装饰必须支持具有add、remove、getChild操作的component接口</p><h1 id="代理模式" tabindex="-1"><a class="header-anchor" href="#代理模式" aria-hidden="true">#</a> 代理模式</h1><ul><li>虚拟代理</li><li>缓存代理</li></ul><p>#装饰者模式 给对象动态地增加职责的方式</p><h3 id="aop装饰函数" tabindex="-1"><a class="header-anchor" href="#aop装饰函数" aria-hidden="true">#</a> AOP装饰函数</h3><p><code>Function.prototype.before</code>和<code>Function.prototype.after</code>方法</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">before</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">beforefn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">//保存原函数的引用</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 返回包含了原函数和新函数的代理函数</span>
        <span class="token function">beforefn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行新函数，且保证this不被劫持，新函数接受的参数也会被原封不动地传入原函数，新函数在原函数之前执行</span>
        <span class="token keyword">return</span> <span class="token function">__self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 执行原函数并返回原函数的执行结果，并且保证this不被劫持</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token class-name">Function</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">after</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">afterfn</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> __self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">var</span> ret <span class="token operator">=</span> <span class="token function">__self</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterfn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>注意：函数通过<code>Function.prototype.before</code>和<code>Function.prototype.after</code>被装饰后，返回的实际上是一个新函数，如在原函数上保存了一些属性，那么这些属性会丢失。</p><p>另这种装饰方式也叠加了函数的作用域，如果装饰的链条太长，性能上也会受到一些影响</p><h1 id="外观模式" tabindex="-1"><a class="header-anchor" href="#外观模式" aria-hidden="true">#</a> 外观模式</h1><p>作用：</p><ul><li>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构</li><li>在开发阶段，子系统往往因为不断的重构演变而变得越来越复杂，增加外观Facade类可以提供一个简单的接口，减少他们之间的依赖。</li><li>在维护一个遗留的大型系统时，为系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互。</li></ul><p>注意事项：</p><ul><li>外观模式被开发者连续使用时会产生一定的性能问题，因为在每次调用时都要检测功能的可用性</li></ul><h1 id="工厂模式" tabindex="-1"><a class="header-anchor" href="#工厂模式" aria-hidden="true">#</a> 工厂模式</h1><p>工厂模式定义一个用户创建对象的接口，这个接口由子类决定实例化哪一个类。该模式使一个类的实例化延迟到了子类。而子类可以重写接口方法以便创建的时候指定自己的对象类型（抽象工厂）</p><ul><li>作用： <ul><li>对象的构建十分复杂</li><li>需要依赖具体的环境创建不同实例</li><li>处理大量具有相同属性的小对象</li></ul></li><li>注意事项： <ul><li>不能滥用工厂，有时候仅仅是给代码增加复杂度</li></ul></li></ul><h1 id="适配器模式" tabindex="-1"><a class="header-anchor" href="#适配器模式" aria-hidden="true">#</a> 适配器模式</h1><p>适配器模式是将一个类（对象）的接口（方法或属性）转换成客户希望的另外一个接口，设配器模式使得原来由于接口不兼容而不能一起工作的那些类可以一起作用</p><h1 id="设计原则与编程技巧" tabindex="-1"><a class="header-anchor" href="#设计原则与编程技巧" aria-hidden="true">#</a> 设计原则与编程技巧</h1><h2 id="单一职责原则" tabindex="-1"><a class="header-anchor" href="#单一职责原则" aria-hidden="true">#</a> 单一职责原则</h2><h2 id="最少知识原则" tabindex="-1"><a class="header-anchor" href="#最少知识原则" aria-hidden="true">#</a> 最少知识原则</h2><h2 id="开放封闭原则" tabindex="-1"><a class="header-anchor" href="#开放封闭原则" aria-hidden="true">#</a> 开放封闭原则</h2><p>开放-封闭原则的思想：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序源代码。</p><p>用对象的多态性消除条件分支</p><p>把程序中不变的部分隔离出来，把可变的部分封装起来</p><p>帮助我们编写遵守开发-封闭原则的代码：</p><ol><li>放置挂钩（hook）</li><li>使用回调函数</li></ol><p>有些代码是无论如何也不能完全封闭的，总会存在一些无法对其封闭的变化。</p><ul><li>挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化</li><li>在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。</li></ul><h1 id="接口和面向接口编程" tabindex="-1"><a class="header-anchor" href="#接口和面向接口编程" aria-hidden="true">#</a> 接口和面向接口编程</h1><p>接口的几种含义：</p><ul><li><p>经常说的一个库或者模块对外提供了某某api接口。通过主动暴露的接口来通信，可以隐藏软件系统内部的工作细节。</p></li><li><p>语言提供的关键字 interface。产生一个完全抽象的类，用来表示一种契约，专门负责建立类与类之间的联系。</p></li><li><p>面向接口编程中的接口</p><p>接口是对象能响应的请求的集合</p><p>抽象类和infterfacede作用主要都是：</p><ul><li>通过向上转型来隐藏对象的真正类型，以表现对象的多态性</li><li>约定类与类之间的一些契约行为</li></ul></li></ul><h1 id="代码重构" tabindex="-1"><a class="header-anchor" href="#代码重构" aria-hidden="true">#</a> 代码重构</h1><ul><li>提炼函数 <ul><li>避免出现超大函数</li><li>独立出来的函数有助于代码复用</li><li>独立出来的函数更容易被覆写</li><li>独立出来的函数如果拥有良好的命名，它本身就起到了注释的作用</li></ul></li><li>合并重复的条件片段</li></ul><p>如果一个函数体内有一些条件分支语句，而这些条件分支语句内部散步了一些重复的代码，那么久有必要进行合并去重工作。</p><ul><li>把条件分支语句提炼成函数</li></ul><p>复杂的条件分支语句是导致程序难以阅读和理解的重要原因，而且容易导致一个庞大的函数。</p><ul><li>合理使用循环</li></ul><p>在函数体内，如果有些代码负责的是一些重复性的工作，那么合理利用循环不仅可以完成同样的功能，还可以使代码量更少。</p><ul><li>提前让函数退出，代替嵌套条件分支</li></ul><p>面对一个嵌套的if分支时，我们可以把外层if表达式进行反转</p><ul><li>传递对象参数代替过长的参数列表</li><li>尽量减少参数数量</li><li>少用三目运算符</li><li>合理使用链式调用</li></ul><p>链式调用会导致调试和维护困难</p><ul><li>分解大型类</li></ul><p>面向对象设计鼓励将行为分布在合理数量的更小对象之中</p><ul><li>用return退出多重循环</li></ul><p>用return直接退出方法会带来一个问题，如果在循环之后还有一些要被执行的代码，退出之后，这些代码就不能执行。</p><p>可把循环后面的代码放到return 后面，如果代码比较多，就提炼成一个单独的函数。</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: wupan1030@foxmail.com">sindorei</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.db66e77f.js" defer></script>
  </body>
</html>
