## 让自己习惯JavaScript
### 1.了解你使用的javascript版本
- 决定你的应用程序支持JavaScript的哪些版本
- 确保你使用的任何JavaScript的特性对于应用程序将要运行的所有环境都是支持的
- 总是在执行严格模式检查的环境中测试严格代码
- 当心连接那些在不同严格模式下有不同预期的脚本
### 2.理解javascript的浮点数
- 双精度浮点数
- IEEE 754 标准 64位编码数字
- javascript中的整数仅仅是双精度浮点数的一个子集，而不是单独的数据类型
- 位运算符将数字视为32位的有符号整数
- 当心浮点数运算中的精度陷阱
### 3.当心隐式的强制转换
- 类型错误可能被隐式的强制转换所隐藏
- 重载的运算符`+`是进行加法运算还是字符串连接操作取决于其参数类型
- 对象通过`valueOf`方法强制转换为数字，通过`toString`方法强制转换为字符串
- 具有`valueOf`方法的对象应该实现`toString`方法，返回一个`valueOf`方法产生的数字的字符串表示
- 测试一个值是否为未定义的值，应该使用typeof或者与undefined进行比较而不是使用真值运算
### 4.原始类型优于封装对象
- 5个原始类型
  - 布尔
  - 数字
  - 字符串
  - null
  - undefined
- 当做相等比较时，原始类型的封装对象与其原始值行为不一样
- 获取和设置原始类型值的属性会隐式地创建封装对象

### 5.避免对混合类型使用 == 运算

### 6.了解分号插入的局限

### 7.视字符串为16位的代码单元序列
- javascript字符串由16位的代码单元组成，而不是由Unicode代码点组成
- 使用第三方的库编写可识别代码点的字符串操作
## 变量作用域
### 8.尽量少用全局对象
- 避免声明全局变量
- 尽量申明局部变量
- 避免对全局对象添加属性
- 使用全局对象来做平台特性检测
### 9. 始终声明局部变量
### 10.避免使用with
- 使用简短的变量名代替重复访问的对象
### 11.熟练掌握闭包
- javascript允许你引用在当前函数以外定义的变量
- 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量
- 闭包可以更新外部变量的值

### 12.理解变量声明提升
### 13.使用立即调用的函数表达式创建局部作用域
- IIFE（发音iffy）

### 14.当心命名函数表达式笨拙的作用域
### 15.当心局部块函数声明笨拙的作用域
- 始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为
- 使用var声明和有条件的赋值语句替代有条件的函数声明

### 16.避免使用eval创建局部变量
- 避免使用eval函数创建的变量污染调用者的作用域
- 如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染

### 17.间接调用eval函数优于直接调用
- 将eval函数同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的
- 尽可能间接调用eval函数，而不要直接调用eval函数
## 使用函数
### 18.理解函数调用、方法调用及构造函数调用之间的不同
- 方法调用将被被查找方法属性的对象作为调用接收者
- 函数调用将全局对象（严格模式下为undefined）作为其接收者
- 构造函数需要通过new运算符调用，并产生一个新的对象作为其接收者
### 19.熟练掌握高阶函数
- 高阶函数是那些将函数作为参数或返回值的函数
- 熟悉掌握现有库中的高阶函数
- 学会发现可以被高阶函数所取代的常见的编码模式
### 20.使用call方法自定义接收者来调用方法
- 使用call方法自定义接收者来调用函数
- 使用call方法可以调用在给定的对象中不存在的方法
- 使用call方法定义高阶函数允许使用者给回调函数指定接收者
### 21.使用apply方法通过不同数量的参数调用函数
### 22.使用arguments创建可变参数的函数
### 23.永远不要修改arguments对象
### 24.使用变量保存arguments的引用
### 25.使用bind方法提取具有确定接收者的方法
### 26.使用bind方法实现函数柯里化
### 27.使用闭包而不是字符串来封装代码
### 28.不要信赖函数对象的toString方法
- ECMAScript标准对函数对象的toString方法的返回结果并没有任何要求（不同的JavaScript引擎可能产生不同的字符串，没有要求能够精确地获取到函数的源代码）
- toString方法的执行结果并不会暴露存储在闭包中的局部变量值
### 29.避免使用非标准的栈检查属性
- 避免使用非标的`arguments.caller`和`arguments.callee`属性，因为它们不具备良好的移植性
- 避免使用非标准的函数对象caller属性，因为在包含全部栈信息方面，它是不可靠的

## 对象和原型
### 30.理解prototype、getPrototypeOf和__proto__之间的不同
### 31.使用Object.getPrototypeOf函数而不要是用__proto__属性
### 32.始终不要修改__proto__属性
### 33.使构造函数与new 操作符无关
### 34.在原型中存储方法
### 35.使用闭包存储私有数据
- 闭包变量是私有的，只能通过局部的引用获取
- 将局部变量作为私有数据从而通过方法实现信息隐藏
### 36.只将实例状态存储在实例对象中
- 共享可变数据可能会出问题，因为原型是被其所有的实例共享的
- 将可变的实例状态存储在实例对象中
### 37.认识到this变量的隐式绑定问题
- this变量的作用域总是由其最近的封闭函数所确定
- 使用一个全局变量（通常命名为self、me或者that）使得this绑定对于内部函数是可用的
### 38.在子类的构造函数中调用父类的构造函数
- 在子类构造函数中显式地传入this作为显式的接收者调用父类构造函数
- 使用Object.create函数来构造子类的原型对象以免调用父类的构造函数
### 39.不要重用父类的属性名
### 40.避免继承标准类
- 继承标准类（js内置的Array、Boolean等）往往会由于一些特殊的内部属性（如[[Class]]）而被破坏
- 使用属性委托优于继承标准类
### 41.将原型视为实现细节
- 对象是接口，原型是实现
- 避免检查你无法控制的对象的原型结构
- 避免检查实现在你无法控制的对象内部的属性
### 42.避免使用轻率的猴子补丁
- 避免使用轻率的猴子补丁
- 记录程序库所执行的所有的猴子补丁
- 考虑通过将修改置于一个导出函数中，使猴子补丁成为可选的
- 使用猴子补丁为缺失的标准API提供polyfills

## 数组和字典
## 库和API设计
### 53.保持一致的约定
- 在变量命名和函数签名中使用一致的约定
- 不要偏离用户在他们的开发平台中很可能遇到的约定

### 54.将undefined看做“没有值”
- 避免使用undefined表示任何非特定值
- 使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined或null来代表特定应用标识
- 提供参数默认值应当采用测试undefined的方式，而不是检查arguments.length
- 在允许0、NaN或空字符串为有效参数的地方，绝不要通过真值测试来实现参数默认值（应判断是否为undefined）

### 55.接受关键字参数的选项对象
- 使用选项对象使得API更具有可读性、更容易记忆
- 所有通过选项对象提供的参数应当被视为可选的
- 使用extend函数抽象出从选项对象中提取值的逻辑

### 56. 避免不必要的状态

### 57.使用结构类型设计灵活的接口

### 58.区分数组对象和类数组对象

### 59.避免过度的强制转换

### 60.支持方法链


## 并发

### 61.不要组设I/O事件队列

### 62.在异步队列中使用嵌套或命名的回调函数

### 63.当心丢弃错误

### 64.对异步循环使用递归

### 65.不要再计算时阻塞事件队列

### 66.使用计数器来执行并行操作

### 67.绝不要同步地调用异步的回调函数

### 68.使用promise模式清洁异步逻辑
