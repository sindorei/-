### 1.了解你使用的javascript版本
### 2.理解javascript的浮点数
- 双精度浮点数
- IEEE 754 标准 64位编码数字

### 3.当心隐式的强制转换

### 4.原始类型优于封装对象
- 5个原始类型
  - 布尔
  - 数字
  - 字符串
  - null
  - undefined
- 当做相等比较时，原始类型的封装对象与其原始值行为不一样
- 获取和设置原始类型值的属性会隐式地创建封装对象

### 5.避免对混合类型使用 == 运算

### 6.了解分号插入的局限

### 7.视字符串为16位的代码单元序列
- javascript字符串由16位的代码单元组成，而不是由Unicode代码点组成
- 使用第三方的库编写可识别代码点的字符串操作

### 8.尽量少用全局对象
### 9. 始终声明局部变量
### 10.避免使用with
### 11.熟练掌握闭包
- javascript允许你引用在当前函数以外定义的变量
- 即使外部函数已经返回，当前函数仍然可以引用在外部函数所定义的变量
- 闭包可以更新外部变量的值

### 12.理解变量声明提升
### 13.使用立即调用的函数表达式创建局部作用域
- IIFE（发音iffy）

### 14.当心命名函数表达式笨拙的作用域
### 15.当心局部块函数声明笨拙的作用域
- 始终将函数声明置于程序或被包含的函数的最外层以避免不可移植的行为
- 使用var声明和有条件的赋值语句替代有条件的函数声明

### 16.避免使用eval创建局部变量
- 避免使用eval函数创建的变量污染调用者的作用域
- 如果eval函数代码可能创建全局变量，将此调用封装到嵌套的函数中以防止作用域污染

### 17.间接调用eval函数优于直接调用
- 将eval函数同一个毫无意义的字面量包裹在序列表达式中以达到强制使用间接调用eval函数的目的
- 尽可能间接调用eval函数，而不要直接调用eval函数

### 18.理解函数调用、方法调用及构造函数调用之间的不同
### 19.熟练掌握高阶函数
### 20.使用call方法自定义接收者来调用方法
### 21.使用apply方法通过不同数量的参数调用函数
### 22.使用arguments创建可变参数的函数
### 23.永远不要修改arguments对象
### 24.使用变量保存arguments的引用
### 25.使用bind方法提取具有确定接收者的方法
### 26.使用bind方法实现函数柯里化

## 库和API设计
### 53.保持一致的约定
- 在变量命名和函数签名中使用一致的约定
- 不要偏离用户在他们的开发平台中很可能遇到的约定

### 54.将undefined看做“没有值”
- 避免使用undefined表示任何非特定值
- 使用描述性的字符串值或命名布尔属性的对象，而不要使用undefined或null来代表特定应用标识
- 提供参数默认值应当采用测试undefined的方式，而不是检查arguments.length
- 在允许0、NaN或空字符串为有效参数的地方，绝不要通过真值测试来实现参数默认值（应判断是否为undefined）

### 55.接受关键字参数的选项对象
- 使用选项对象使得API更具有可读性、更容易记忆
- 所有通过选项对象提供的参数应当被视为可选的
- 使用extend函数抽象出从选项对象中提取值的逻辑

### 56. 避免不必要的状态

### 57.使用结构类型设计灵活的接口

### 58.区分数组对象和类数组对象

### 59.避免过度的强制转换

### 60.支持方法链


## 并发

### 61.不要组设I/O事件队列

### 62.在异步队列中使用嵌套或命名的回调函数

### 63.当心丢弃错误

### 64.对异步循环使用递归

### 65.不要再计算时阻塞事件队列

### 66.使用计数器来执行并行操作

### 67.绝不要同步地调用异步的回调函数

### 68.使用promise模式清洁异步逻辑
